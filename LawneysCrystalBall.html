<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2Q8QRWJM8E"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2Q8QRWJM8E');
</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Combat Simulator v2.0</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=MedievalSharp&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark-void: #0d0a1a;
            --bg-light-void: #1a1433;
            --text-luminous: #e0e0ff;
            --text-normal: #a0a0c0;
            --accent-gold: #ffd700;
            --accent-purple: #9d4edd;
            --accent-red: #c70039;
            --accent-green: #00b377;
            --accent-blue: #00aaff;
            --accent-teal: #00f5d4;
            --current-accent: var(--accent-teal); /* Default accent color */
        }
        
        body { font-family: 'Cinzel', serif; background-color: var(--bg-dark-void); background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,0.1) 1px, transparent 0); background-size: 40px 40px; color: var(--text-luminous); margin: 0; padding: 1.5rem; }
        .container { max-width: 1200px; margin: auto; background-color: rgba(26, 20, 51, 0.8); backdrop-filter: blur(5px); padding: 2rem; border-radius: 15px; border: 2px solid var(--current-accent); box-shadow: 0 0 30px var(--current-accent); transition: border-color 0.3s, box-shadow 0.3s; }
        
        /* Tab-specific Accent Colors */
        .container.tab-0-active { --current-accent: var(--accent-teal); }
        .container.tab-1-active { --current-accent: var(--accent-purple); }
        .container.tab-2-active { --current-accent: var(--accent-red); }
        .container.tab-3-active { --current-accent: var(--accent-blue); }

        h1 { font-family: 'MedievalSharp', cursive; font-size: 3rem; color: var(--accent-gold); text-align: center; text-shadow: 0 0 10px var(--accent-gold); margin-top: 0; margin-bottom: 1rem; }
        h2 { font-family: 'MedievalSharp', cursive; font-size: 2rem; color: var(--text-luminous); margin: 2rem 0 1rem 0; text-align: center; border-bottom: 1px solid var(--current-accent); padding-bottom: 0.5rem; }
        
        /* Tab Styles */
        .tab-navigation { display: flex; flex-wrap: wrap; border-bottom: 2px solid var(--current-accent); margin-bottom: 1.5rem; }
        .tab-button { background: none; border: none; color: var(--text-normal); padding: 10px 20px; font-family: 'Cinzel', serif; font-size: 1.1rem; font-weight: 700; cursor: pointer; transition: all 0.2s; border-bottom: 3px solid transparent; }
        .tab-button.active { color: var(--accent-gold); border-bottom-color: var(--accent-gold); }
        .tab-button:hover { color: var(--text-luminous); }
        .tab-content { display: none; }
        .tab-content.active { display: block; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Welcome Page Styles */
        .welcome-page { text-align: center; padding: 1rem 0; }
        .welcome-page h2 { border-bottom: none; margin-top: 0; color: var(--accent-teal); }
        .welcome-page p.intro { font-size: 1.2rem; max-width: 800px; margin: 0 auto 3rem auto; line-height: 1.7; color: var(--text-normal); }
        .features-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 2rem; margin-bottom: 3rem; }
        .feature-box { background-color: var(--bg-light-void); padding: 2rem; border-radius: 10px; border: 1px solid var(--current-accent); text-align: center; transition: all 0.3s; }
        .feature-box:hover { transform: translateY(-5px); box-shadow: 0 5px 20px rgba(0, 245, 212, 0.2); }
        .feature-box h3 { font-family: 'MedievalSharp', cursive; font-size: 1.8rem; margin-top: 0; margin-bottom: 1rem; color: var(--text-luminous); }
        .feature-box .feature-icon { margin-bottom: 1rem; }
        .feature-box .feature-icon svg { width: 48px; height: 48px; stroke: var(--current-accent); stroke-width: 1.5; fill: none; }
        .feature-box p { color: var(--text-normal); line-height: 1.6; margin-bottom: 1.5rem; }
        .go-to-tab-btn { font-family: 'Cinzel', serif; font-size: 1rem; font-weight: 700; padding: 10px 25px; border-radius: 5px; cursor: pointer; background: transparent; transition: all 0.2s; border: 2px solid var(--current-accent); color: var(--current-accent); text-transform: uppercase; }
        .go-to-tab-btn:hover { background-color: var(--current-accent); color: var(--bg-dark-void); box-shadow: 0 0 15px var(--current-accent); }

        /* Preset Styles */
        .preset-manager { background-color: rgba(0,0,0,0.2); padding: 1rem; border-radius: 8px; margin-top: 1rem; display: flex; gap: 1rem; align-items: center; justify-content: space-between; flex-wrap: wrap; }
        .preset-controls, .preset-save-controls { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
        .preset-manager label { font-weight: 700; }
        .preset-manager select { font-family: 'Cinzel', serif; font-size: 1rem; background-color: var(--bg-dark-void); border: 1px solid var(--current-accent); color: var(--text-luminous); padding: 8px; border-radius: 4px; }
        .preset-manager optgroup { font-family: 'Cinzel', serif; font-style: italic; background-color: var(--bg-light-void); }
        .preset-manager option { font-style: normal; }
        .preset-name-input { font-family: 'Cinzel', serif; font-size: 1rem; background-color: var(--bg-dark-void); border: 1px solid var(--current-accent); color: var(--text-luminous); padding: 8px; border-radius: 4px; width: 200px; transition: border-color 0.2s, box-shadow 0.2s; }
        .preset-name-input.invalid { border-color: var(--accent-red); box-shadow: 0 0 8px var(--accent-red); }
        .preset-manager button { font-family: 'Cinzel', serif; font-size: 1rem; font-weight: 700; padding: 8px 15px; border-radius: 5px; cursor: pointer; background: transparent; transition: all 0.2s; border: 1px solid; }
        .btn-save { border-color: var(--accent-gold); color: var(--accent-gold); }
        .btn-save:hover { background-color: var(--accent-gold); color: var(--bg-dark-void); }
        .btn-save:disabled { cursor: not-allowed; opacity: 0.7; background-color: var(--accent-gold); color: var(--bg-dark-void); }
        .btn-delete { border-color: var(--accent-red); color: var(--accent-red); }
        .btn-delete:hover { background-color: var(--accent-red); color: white; }
        .btn-delete:disabled { border-color: var(--text-normal); color: var(--text-normal); opacity: 0.5; cursor: not-allowed; }
        .btn-delete:disabled:hover { background: transparent; color: var(--text-normal); }

        
        /* General Component Styles for Tabs 2 & 3 */
        .calc-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; align-items: flex-start; }
        .input-group { background-color: var(--bg-light-void); padding: 1.5rem; border-radius: 8px; border: 1px solid var(--current-accent); }
        .input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.2rem; }
        .input-row:last-child { margin-bottom: 0; }
        .input-row label { font-weight: 700; font-size: 1.1rem; }
        .input-row .checkbox-option-wrapper { display: flex; align-items: center; gap: 0.5rem; flex-shrink: 0; }
        .input-row .checkbox-option-wrapper input[type="checkbox"] { width: auto; transform: scale(1.2); cursor: pointer; accent-color: var(--current-accent); }
        .input-row .checkbox-option-wrapper label { font-size: 1rem; font-weight: normal; cursor: pointer; }
        .input-row .checkbox-option-wrapper label[for="ac-compare-override-toggle"] { color: var(--accent-gold); font-weight: 700; }
        .ac-controls-wrapper { display: flex; align-items: center; gap: 0.75rem; }
        .input-row input[type="number"], .input-row input[type="text"] { font-family: 'Cinzel', serif; font-size: 1.2rem; background-color: var(--bg-dark-void); border: 1px solid var(--current-accent); color: var(--text-luminous); padding: 5px; border-radius: 4px; text-align: center; width: 120px; transition: border-color 0.2s; }
        .input-row input:disabled { background-color: #111; color: var(--text-normal); border-color: var(--text-normal); cursor: not-allowed; }
        .input-row input.invalid { border-color: var(--accent-red); box-shadow: 0 0 8px var(--accent-red); }
        .toggle-group { display: flex; border-radius: 5px; overflow: hidden; border: 1px solid var(--current-accent); }
        .toggle-group label { padding: 8px 12px; cursor: pointer; transition: background-color 0.2s; font-size: 1rem; }
        .toggle-group input { display: none; }
        .toggle-group input:checked + label { background-color: var(--current-accent); color: white; }
        .results-group { text-align: center; background-color: var(--bg-dark-void); padding: 1rem; border-radius: 8px; border: 1px solid var(--accent-gold); margin-bottom: 2rem; }
        .main-result-display { margin-top: 1rem; }
        .main-result-total { font-size: 4rem; color: var(--accent-gold); text-shadow: 0 0 10px var(--accent-gold); font-weight: bold; }
        .main-result-label { font-size: 1.2rem; color: var(--text-normal); margin-top: -10px; display: block; }
        .results-breakdown { margin-top: 1.5rem; text-align: left; font-size: 0.9rem; line-height: 1.6; color: var(--text-normal); }
        .results-breakdown span { color: var(--text-luminous); font-weight: bold; float: right; }
        .results-breakdown hr { border-color: var(--current-accent); opacity: 0.5; }
        .error-message { color: var(--accent-red); font-weight: bold; font-size: 0.9rem; height: 1.2em; margin-top: 1rem; }
        
        .simulation-result { background-color: var(--bg-dark-void); padding: 1rem; border-radius: 8px; min-height: 2.5em; text-align: center; border: 1px solid var(--current-accent); margin-bottom: 2rem; font-size: 1.1rem; line-height: 1.5; color: var(--text-luminous); }
        .simulation-result .placeholder { color: var(--text-normal); font-style: italic; }
        .simulation-result hr { border-color: var(--current-accent); opacity: 0.5; margin: 0.5rem 0;}

        /* Dice Playground Styles */
        .roll-builder { display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-top: 2rem; margin-bottom: 2rem; }
        .die-control { background-color: var(--bg-dark-void); border: 1px solid var(--accent-purple); border-radius: 8px; padding: 1rem; display: flex; flex-direction: column; align-items: center; gap: 0.75rem; text-align: center; }
        .die-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }
        .die-icon { width: 32px; height: 32px; stroke: var(--accent-purple); fill: none; stroke-width: 2; }
        .die-label { font-size: 1.5rem; font-weight: 700; color: var(--text-luminous); }
        .control-row { display: flex; align-items: center; justify-content: space-between; width: 100%; }
        .control-row > span { font-size: 0.9rem; color: var(--text-normal); }
        .btn-adjust { background-color: var(--bg-light-void); color: var(--text-luminous); border: 1px solid var(--accent-purple); width: 26px; height: 26px; font-size: 1.4rem; font-weight: bold; border-radius: 50%; cursor: pointer; line-height: 20px; transition: all 0.2s; }
        .btn-adjust:hover { background-color: var(--accent-purple); box-shadow: 0 0 5px var(--accent-purple); }
        .btn-adjust:disabled { cursor: not-allowed; opacity: 0.3; background-color: var(--bg-light-void); }
        .btn-adjust:disabled:hover { box-shadow: none; }
        .die-input { font-family: 'Cinzel', serif; font-size: 1.4rem; font-weight: 700; color: var(--text-luminous); width: 45px; text-align: center; border: none; background: transparent; border-bottom: 1px solid transparent; }
        .die-input:focus { outline: none; border-bottom: 1px solid var(--accent-gold); }
        .die-input { -moz-appearance: textfield; } .die-input::-webkit-outer-spin-button, .die-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .label-drop-low { color: var(--accent-green); } 
        .label-drop-high { color: var(--accent-red); }
        .action-buttons { display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 2rem; }
        .btn-action { flex-grow: 1; padding: 15px 20px; font-size: 1.2rem; font-weight: 700; border-width: 2px; border-style: solid; border-radius: 5px; cursor: pointer; background: transparent; transition: all 0.2s; text-transform: uppercase; }
        .btn-action:disabled {
            border-color: var(--text-normal);
            color: var(--text-normal);
            opacity: 0.5;
            cursor: not-allowed;
            background: transparent;
            box-shadow: none;
        }
        
        .btn-future { border-color: var(--current-accent); color: var(--current-accent); }
        .btn-future:hover:not(:disabled) { background-color: var(--current-accent); color: var(--bg-dark-void); box-shadow: 0 0 15px var(--current-accent); }
        
        .btn-freeze { border-color: var(--accent-gold); color: var(--accent-gold); }
        .btn-freeze:hover:not(:disabled) { background-color: var(--accent-gold); color: var(--bg-dark-void); box-shadow: 0 0 15px var(--accent-gold); }
        
        .btn-clear { border-color: var(--text-normal); color: var(--text-normal); }
        .btn-clear:hover:not(:disabled) { background-color: var(--text-normal); color: var(--bg-dark-void); box-shadow: 0 0 15px var(--text-normal); }
        
        #result-display { background-color: var(--bg-dark-void); padding: 1rem; border-radius: 8px; min-height: 120px; text-align: center; border: 1px solid var(--accent-purple); margin-bottom: 2rem; }
        #result-total { font-size: 3.5rem; font-weight: bold; color: var(--accent-gold); display: block; text-shadow: 0 0 10px var(--accent-gold); }
        #result-status { font-size: 1.5rem; font-weight: bold; display: block; margin-top: 0.5rem; }
        .success { color: var(--accent-green); text-shadow: 0 0 5px var(--accent-green); } .failure { color: var(--accent-red); text-shadow: 0 0 5px var(--accent-red); }
        #result-details { font-size: 0.9rem; color: var(--text-normal); margin-top: 0.5rem; line-height: 1.5; word-wrap: break-word; }
        
        /* Chart Styles */
        .chart-info { text-align: center; font-size: 1rem; line-height: 1.5; margin-bottom: 0.75rem; min-height: 1.2em; }
        .current-info-text { color: var(--current-accent); font-weight: bold; }
        .frozen-info-text { color: var(--accent-gold); font-weight: bold; }
        .chart-container { min-height: 300px; width: 100%; position: relative; }
        .chart-message { font-size: 1.2rem; color: var(--text-normal); text-align: center; padding-top: 5rem; }
        .chart-line { stroke: var(--current-accent); stroke-width: 2; fill: none; }
        .frozen-line { stroke: var(--accent-gold); stroke-width: 2; fill: none; opacity: 0.8; }
        .dc-line, .result-line { stroke-width: 2; }
        .dc-line { stroke: var(--text-luminous); stroke-dasharray: 4 4; }
        .result-line { stroke: var(--accent-gold); }
        .dc-text, .result-text { font-size: 11px; }
        .dc-text { fill: var(--text-luminous); }
        .result-text { fill: var(--accent-gold); }
        .chart-dot-current, .chart-dot-frozen { stroke: var(--bg-dark-void); stroke-width: 1; cursor: pointer; }
        .chart-dot-current { fill: var(--current-accent); }
        .chart-dot-frozen { fill: var(--accent-gold); }
        .axis-line, .axis-tick line { stroke: var(--text-normal); stroke-width: 1; }
        .axis-tick text, .axis-label { fill: var(--text-normal); font-size: 10px; }
        .axis-label { font-size: 12px; font-weight: bold; }
        .chart-subtitle { font-size: 11px; fill: #aaa; font-style: italic; }
        .current-subtitle-text { fill: var(--current-accent); font-weight: bold; }
        .frozen-subtitle-text { fill: var(--accent-gold); font-weight: bold; }

        /* Footer Styles */
        .footer-link { display: flex; justify-content: center; align-items: center; gap: 1rem; flex-wrap: wrap; text-align: center; margin-top: 2rem; }
        .footer-label { color: var(--text-normal); font-family: 'MedievalSharp', cursive; font-size: 1.2rem; }
        .footer-link a { color: var(--text-normal); text-decoration: none; border: 1px solid var(--text-normal); padding: 8px 15px; border-radius: 5px; transition: all 0.2s; }
        .footer-link a:hover { color: var(--bg-dark-void); background-color: var(--text-normal); }
        a.paypal-link:hover { border-color: #0070ba; background-color: #0070ba; color: white; }
        a.venmo-link:hover { border-color: #008CFF; background-color: #008CFF; color: white; }

        /* Responsive Media Queries */
        @media (max-width: 900px) { .roll-builder { grid-template-columns: repeat(2, 1fr); } h1 { font-size: 2.5rem; } .calc-grid { grid-template-columns: 1fr; } }
        @media (max-width: 768px) { .preset-manager { flex-direction: column; align-items: stretch; } }
        @media (max-width: 600px) { .roll-builder { grid-template-columns: 1fr; } h1 { font-size: 2rem; } .container { padding: 1rem; } .tab-navigation { flex-direction: column; } }
    </style>
</head>
<body>
    <div class="container tab-0-active">
        <h1>Lawneys Crystal Ball</h1>

        <nav class="tab-navigation">
            <button class="tab-button active" data-tab="tab-0">Welcome</button>
            <button class="tab-button" data-tab="tab-1">Dice Playground</button>
            <button class="tab-button" data-tab="tab-2">Attack Roll Calculator</button>
            <button class="tab-button" data-tab="tab-3">Saving Throw Calculator</button>
        </nav>

        <div id="tab-0" class="tab-content active">
            <div class="welcome-page">
                <h2>Your D&D Probability Oracle</h2>
                <p class="intro">
                    Whether you're a Dungeon Master crafting the next great encounter or a player optimizing your build, the Crystal Ball offers a glimpse into the myriad futures of your dice rolls. Analyze, simulate, and master the odds.
                </p>
                <div class="features-grid">
                    <div class="feature-box">
                        <div class="feature-icon">
                            <svg viewBox="0 0 32 32"><path d="M16 2 L30 11 L24 29 L8 29 L2 11 Z"></path></svg>
                        </div>
                        <h3>Dice Playground</h3>
                        <p>Build any dice combination imaginable. Experiment with advantage, drop-lowest mechanics, and see the full probability distribution before you roll.</p>
                        <button class="go-to-tab-btn" data-target-tab="tab-1">Roll the Bones</button>
                    </div>
                    <div class="feature-box">
                         <div class="feature-icon">
                            <svg viewBox="0 0 32 32"><path d="M16 3 L30 16 L16 29 L2 16 Z"></path></svg>
                        </div>
                        <h3>Attack Calculator</h3>
                        <p>Calculate your Average Damage Per Round (DPR) against any target AC. Factor in multiple attacks, critical hits, and special feats.</p>
                        <button class="go-to-tab-btn" data-target-tab="tab-2">Analyze Attacks</button>
                    </div>
                    <div class="feature-box">
                         <div class="feature-icon">
                             <svg viewBox="0 0 32 32"><path d="M16 2 L28 10 L28 22 L16 30 L4 22 L4 10 Z"></path></svg>
                        </div>
                        <h3>Saving Throw Calculator</h3>
                        <p>Determine the average damage of your spells against single or multiple targets. Account for different save outcomes like half or no damage.</p>
                        <button class="go-to-tab-btn" data-target-tab="tab-3">Calculate Spells</button>
                    </div>
                </div>
                 <p class="intro" style="font-size: 1.1rem; margin-bottom: 1rem;">The future is not yet written. Choose your tool and begin your divination.</p>
            </div>
        </div>

        <div id="tab-1" class="tab-content">
            <div class="preset-manager" data-tab-id="tab-1">
                <div class="preset-controls">
                    <label for="playground-presets">Presets:</label>
                    <select id="playground-presets" class="preset-select"></select>
                    <button class="btn-delete">Delete Selected</button>
                </div>
                <div class="preset-save-controls">
                    <input type="text" class="preset-name-input" placeholder="New Preset Name">
                    <button class="btn-save">Save</button>
                </div>
            </div>
            <div id="roll-builder" class="roll-builder"></div>
            <div class="action-buttons">
                <button id="playground-future-button" class="btn-action btn-future">View the Future</button>
                <button id="playground-freeze-button" class="btn-action btn-freeze">Freeze for Comparison</button>
                <button id="playground-clear-button" class="btn-action btn-clear">Clear Slate</button>
            </div>
            <div id="result-display">
                <span id="result-total" class="placeholder">Awaiting Fate...</span>
                <span id="result-status"></span>
                <span id="result-details"></span>
            </div>
            <h2>Probability Distribution</h2>
            <div id="playground-chart-info" class="chart-info"></div>
            <div id="playground-chart-container" class="chart-container"></div>
        </div>

        <div id="tab-2" class="tab-content">
            <div class="preset-manager" data-tab-id="tab-2">
                 <div class="preset-controls">
                    <label for="attack-presets">Presets:</label>
                    <select id="attack-presets" class="preset-select"></select>
                    <button class="btn-delete">Delete Selected</button>
                </div>
                <div class="preset-save-controls">
                    <input type="text" class="preset-name-input" placeholder="New Preset Name">
                    <button class="btn-save">Save</button>
                </div>
            </div>
            <div class="calc-grid" style="margin-top:1rem;">
                <div class="input-group">
                    <div class="input-row">
                        <label>Chart Mode</label>
                        <div class="toggle-group" id="chart-mode-selector">
                            <input type="radio" id="chart-mode-fixed" name="chart-mode" value="fixed" checked><label for="chart-mode-fixed">Fixed AC</label>
                            <input type="radio" id="chart-mode-variable" name="chart-mode" value="variable"><label for="chart-mode-variable">Variable AC</label>
                        </div>
                    </div>
                    <div class="input-row">
                        <label for="attack-bonus">Attack Bonus</label>
                        <input type="text" id="attack-bonus" value="5">
                    </div>
                    <div class="input-row">
                        <label>Target AC</label>
                        <div class="ac-controls-wrapper">
                            <input type="number" id="target-ac" value="15">
                        </div>
                    </div>
                    <div class="input-row">
                        <label for="damage-dice">Damage Formula</label>
                        <input type="text" id="damage-dice" value="2d6+3" style="width: 150px;">
                    </div>
                    <div class="input-row">
                        <label for="attacks-per-turn">Attacks Per Turn</label>
                        <input type="number" id="attacks-per-turn" value="1">
                    </div>
                    <div class="input-row">
                        <label>Attack Roll</label>
                        <div class="toggle-group" id="adv-selector">
                            <input type="radio" id="adv-dis" name="advantage" value="-1"><label for="adv-dis">Dis.</label>
                            <input type="radio" id="adv-norm" name="advantage" value="0" checked><label for="adv-norm">Norm</label>
                            <input type="radio" id="adv-adv" name="advantage" value="1"><label for="adv-adv">Adv.</label>
                        </div>
                    </div>
                </div>
                <div class="results-group">
                    <div class="main-result-display">
                        <span id="adpr-total" class="main-result-total">0.00</span>
                        <span class="main-result-label">Average Damage</span>
                    </div>
                    <div class="results-breakdown" id="adpr-breakdown">
                        <p>Crit Chance: <span id="crit-chance">0%</span></p>
                        <p>Hit Chance: <span id="hit-chance">0%</span></p>
                        <p>Miss Chance: <span id="miss-chance">0%</span></p>
                        <hr>
                        <p>Avg. Damage (1 Atk): <span id="avg-damage">0</span></p>
                        <p>Avg. Crit Dmg (1 Atk): <span id="avg-crit-damage">0</span></p>
                    </div>
                    <div id="adpr-error" class="error-message"></div>
                </div>
            </div>
            <div class="action-buttons">
                <button id="attack-future-button" class="btn-action btn-future">View the Future</button>
                <button id="attack-freeze-button" class="btn-action btn-freeze">Freeze for Comparison</button>
                <button id="attack-clear-button" class="btn-action btn-clear">Clear Slate</button>
            </div>
            <div id="attack-sim-result" class="simulation-result"><span class="placeholder">Awaiting a glimpse of the future...</span></div>
            <h2 id="attack-chart-title" style="margin-top: 1rem;">Average Damage Distribution</h2>
            <div id="adpr-chart-info" class="chart-info"></div>
            <div id="adpr-chart-container" class="chart-container"></div>
        </div>

        <div id="tab-3" class="tab-content">
            <div class="preset-manager" data-tab-id="tab-3">
                 <div class="preset-controls">
                    <label for="save-presets">Presets:</label>
                    <select id="save-presets" class="preset-select"></select>
                    <button class="btn-delete">Delete Selected</button>
                </div>
                <div class="preset-save-controls">
                    <input type="text" class="preset-name-input" placeholder="New Preset Name">
                    <button class="btn-save">Save</button>
                </div>
            </div>
            <div class="calc-grid" style="margin-top:1rem;">
                <div class="input-group">
                    <div class="input-row">
                        <label for="save-dc">Save DC</label>
                        <input type="number" id="save-dc" value="15">
                    </div>
                    <div class="input-row">
                        <label for="save-damage">Damage Formula</label>
                        <input type="text" id="save-damage" value="8d6">
                    </div>
                    <div class="input-row">
                        <label for="target-save-bonus">Target's Save Bonus</label>
                        <input type="text" id="target-save-bonus" value="3">
                    </div>
                    <div class="input-row">
                        <label>Target's Roll</label>
                        <div class="toggle-group" id="save-adv-selector">
                            <input type="radio" id="save-adv-dis" name="save-advantage" value="-1"><label for="save-adv-dis">Dis.</label>
                            <input type="radio" id="save-adv-norm" name="save-advantage" value="0" checked><label for="save-adv-norm">Norm</label>
                            <input type="radio" id="save-adv-adv" name="save-advantage" value="1"><label for="save-adv-adv">Adv.</label>
                        </div>
                    </div>
                    <div class="input-row">
                        <label>Damage on Save</label>
                        <div class="toggle-group" id="save-outcome-selector">
                            <input type="radio" id="save-half" name="save-outcome" value="0.5" checked><label for="save-half">Half</label>
                            <input type="radio" id="save-none" name="save-outcome" value="0"><label for="save-none">None</label>
                        </div>
                    </div>
                    <div class="input-row">
                        <label for="num-targets">Number of Targets</label>
                        <input type="number" id="num-targets" value="1">
                    </div>
                </div>
                <div class="results-group">
                    <div class="main-result-display">
                        <span id="save-total-damage" class="main-result-total">0.00</span>
                        <span class="main-result-label">Total Average Damage</span>
                    </div>
                    <div class="results-breakdown" id="save-breakdown">
                        <p>Success Chance: <span id="save-success-chance">0%</span></p>
                        <p>Failure Chance: <span id="save-fail-chance">0%</span></p>
                        <hr>
                        <p>Dmg on Fail (1 Target): <span id="save-fail-dmg">0</span></p>
                        <p>Dmg on Success (1 Target): <span id="save-success-dmg">0</span></p>
                    </div>
                    <div id="save-error" class="error-message"></div>
                </div>
            </div>
            <div class="action-buttons">
                <button id="save-future-button" class="btn-action btn-future">View the Future</button>
                <button id="save-freeze-button" class="btn-action btn-freeze">Freeze for Comparison</button>
                <button id="save-clear-button" class="btn-action btn-clear">Clear Slate</button>
            </div>
            <div id="save-sim-result" class="simulation-result"><span class="placeholder">Awaiting a glimpse of the future...</span></div>
            <h2 style="margin-top: 1rem;">Total Damage Distribution</h2>
            <div id="save-chart-info" class="chart-info"></div>
            <div id="save-chart-container" class="chart-container"></div>
        </div>
        
        <div class="footer-link">
            <a href="mailto:dannytk4212002@gmail.com?subject=D&D%20Combat%20Simulator%20Feedback">Send Feedback</a>
            <span class="footer-label"> tip your local wizard:</span>
            <!-- UPDATE YOUR LINKS HERE -->
            <a href="https://paypal.me/kenttk421" target="_blank" class="paypal-link">PayPal</a>
            <a href="https://venmo.com/u/daniel-k-Abrams" target="_blank" class="venmo-link">Venmo</a>
        </div>
    </div>

    <script>
        // --- CORE APPLICATION SETUP ---
        const diceTypes = [4, 6, 8, 10, 12, 20, 100];
        const BRUTE_FORCE_LIMIT = 4000000;
        const SIMULATION_COUNT = 50000;
        const CALCULATOR_DICE_LIMIT = 100; // Guard clause for calculator complexity
        
        const LS_LAST_STATE_KEY = 'lawney_crystal_ball_last_state';
        const LS_PRESETS_KEY = 'lawney_crystal_ball_presets';
        let presets = {};

        const DEFAULT_PRESETS = {
            // Tab 1: Dice Playground
            "Roll for stats": { tabId: "tab-1", state: { "d6": { count: 4, dropLow: 1, dropHigh: 0 }, "meta": { value: 0, dc: 0 } } },
            "Advantage Roll": { tabId: "tab-1", state: { "d20": { count: 2, dropLow: 1, dropHigh: 0 }, "meta": { value: 0, dc: 0 } } },
            "Disadvantage Roll": { tabId: "tab-1", state: { "d20": { count: 2, dropLow: 0, dropHigh: 1 }, "meta": { value: 0, dc: 0 } } },
            "Elven Accuracy (Adv)": { tabId: "tab-1", state: { "d20": { count: 3, dropLow: 2, dropHigh: 0 }, "meta": { value: 0, dc: 0 } } },
            
            // Tab 2: Attack Roll Calculator
            "Longsword Attack": { tabId: "tab-2", state: { 'attack-bonus': "5", 'target-ac': "15", 'damage-dice': "1d8+3", 'attacks-per-turn': "1", advState: "0", chartMode: "fixed" } },
            "Longbow (Sneak attack)": { tabId: "tab-2", state: { 'attack-bonus': "5", 'target-ac': "15", 'damage-dice': "1d8+3d6+5", 'attacks-per-turn': "1", advState: "1", chartMode: "fixed" } },
            "Scorching Ray (3 Bolts)": { tabId: "tab-2", state: { 'attack-bonus': "7", 'target-ac': "14", 'damage-dice': "2d6", 'attacks-per-turn': "3", advState: "0", chartMode: "fixed" } },
            
            // Tab 3: Saving Throw Calculator
            "Fireball (Lvl 3)": { tabId: "tab-3", state: { 'save-dc': "15", 'save-damage': "8d6", 'target-save-bonus': "2", 'save-advantage': "0", 'save-outcome': "0.5", 'num-targets': "3" } },
            "Disintegrate (Lvl 6)": { tabId: "tab-3", state: { 'save-dc': "19", 'save-damage': "10d6+40", 'target-save-bonus': "5", 'save-advantage': "0", 'save-outcome': "0", 'num-targets': "1" } },
            "Dragon's Breath (Young Red)": { tabId: "tab-3", state: { 'save-dc': "17", 'save-damage': "16d6", 'target-save-bonus': "4", 'save-advantage': "0", 'save-outcome': "0.5", 'num-targets': "4" } },
        };

        const playgroundState = {};
        const frozenState = { playground: null, attack: null, save: null };
        const simulationResult = { playground: null, attack: null, save: null };

        const diceIcons = {4:`<svg viewBox="0 0 32 32" class="die-icon"><path d="M16 3 L3 22 L29 22 Z M16 3 L16 30"></path></svg>`,6:`<svg viewBox="0 0 32 32" class="die-icon"><rect x="4" y="4" width="24" height="24"></rect></svg>`,8:`<svg viewBox="0 0 32 32" class="die-icon"><path d="M16 3 L30 16 L16 29 L2 16 Z"></path></svg>`,10:`<svg viewBox="0 0 32 32" class="die-icon"><path d="M16 3 L30 12 L30 20 L16 29 L2 20 L2 12 Z"></path></svg>`,12:`<svg viewBox="0 0 32 32" class="die-icon"><path d="M16 2 L28 10 L28 22 L16 30 L4 22 L4 10 Z"></path></svg>`,20:`<svg viewBox="0 0 32 32" class="die-icon"><path d="M16 2 L30 11 L24 29 L8 29 L2 11 Z"></path></svg>`,100:`<svg viewBox="0 0 32 32" class="die-icon"><path d="M14 3 L28 12 L28 20 L14 29 L0 20 L0 12 Z M18 3 L32 12 L32 20 L18 29 L4 20 L4 12 Z"></path></svg>`,meta:`<svg viewBox="0 0 32 32" class="die-icon"><path d="M16 2 A14 14 0 1 1 16 30 A14 14 0 1 1 16 2 Z M8 16 H24 M16 8 V24"></path></svg>`};
        
        const ui = {};
        ['roll-builder', 'playground-future-button', 'playground-clear-button', 'playground-freeze-button', 'result-total', 'result-status', 'result-details', 
         'playground-chart-container', 'playground-chart-info', 'adpr-chart-container', 'adpr-chart-info', 'save-chart-container', 'save-chart-info',
         'attack-future-button', 'attack-freeze-button', 'attack-clear-button', 'attack-sim-result',
         'save-future-button', 'save-freeze-button', 'save-clear-button', 'save-sim-result',
         'attack-chart-title',
         'tab-0'
        ].forEach(id => ui[id.replace(/-/g, '_')] = document.getElementById(id));
        
        // --- INITIALIZATION ---
        function initializeApp() {
            initializeDicePlayground();
            loadPresets();
            loadState();
            setupEventListeners();
            document.querySelectorAll('.preset-manager').forEach(updateDeleteButtonState);
            updateAllButtonStates();
            const activeTabId = document.querySelector('.tab-content.active')?.id;
            if (activeTabId === 'tab-2') {
                calculateADPR();
            } else if (activeTabId === 'tab-3') {
                calculateSaveDamage();
            }
        }

        function setupEventListeners() {
            const debouncedSaveState = debounce(saveState, 500);

            const container = document.querySelector('.container');
            document.querySelector('.tab-navigation').addEventListener('click', (e) => {
                if (e.target.matches('.tab-button')) {
                    const tabId = e.target.dataset.tab;
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById(tabId).classList.add('active');
                    container.className = 'container'; container.classList.add(`${tabId}-active`);
                    
                    if (tabId === 'tab-1') updatePlaygroundChart();
                    if (tabId === 'tab-2') calculateADPR(); 
                    if (tabId === 'tab-3') calculateSaveDamage();
                    debouncedSaveState();
                }
            });
            
            ui.tab_0.addEventListener('click', (e) => {
                if (e.target.classList.contains('go-to-tab-btn')) {
                    const targetTabId = e.target.dataset.targetTab;
                    const targetTabButton = document.querySelector(`.tab-button[data-tab="${targetTabId}"]`);
                    if (targetTabButton) {
                        targetTabButton.click();
                    }
                }
            });

            document.querySelectorAll('.preset-manager').forEach(manager => {
                manager.querySelector('.btn-save').addEventListener('click', savePreset);
                manager.querySelector('.btn-delete').addEventListener('click', deleteSelectedPreset);
                manager.querySelector('.preset-select').addEventListener('change', (e) => {
                    loadPreset(e);
                    updateDeleteButtonState(manager);
                });
            });

            container.addEventListener('input', (e) => {
                if (e.target.matches('input') || e.target.matches('select')) {
                    debouncedSaveState();
                }
            });
            container.addEventListener('change', (e) => {
                 if (e.target.matches('input[type="radio"]') || e.target.matches('input[type="checkbox"]')) {
                    debouncedSaveState();
                }
            });

            ui.roll_builder.addEventListener('click', (event) => { if (!event.target.matches('.btn-adjust')) return; const action = event.target.dataset.action; const input = event.target.parentElement.querySelector('.die-input'); if (!input) return; const currentValue = parseInt(input.value, 10) || 0; input.value = (action === 'increase') ? currentValue + 1 : currentValue - 1; input.dispatchEvent(new Event('input', { bubbles: true })); });
            ui.roll_builder.addEventListener('input', (event) => { if (!event.target.matches('.die-input')) return; const input = event.target; const key = input.closest('.die-control').dataset.key; const type = input.dataset.type; let value = parseInt(input.value, 10); if (isNaN(value)) value = 0; if (key === 'meta') { if (type === 'dc' && value < 0) value = 0; playgroundState.meta[type] = value; } else { if (type !== 'count' && value < 0) value = 0; playgroundState[key][type] = value; const dieState = playgroundState[key]; const absCount = Math.abs(dieState.count); const maxDrops = absCount > 0 ? absCount - 1 : 0; dieState.dropHigh = Math.min(dieState.dropHigh, maxDrops); dieState.dropLow = Math.min(dieState.dropLow, maxDrops - dieState.dropHigh); } updatePlaygroundChart(); syncUiToState(); });
            ui.playground_future_button.addEventListener('click', handleRoll);
            ui.playground_freeze_button.addEventListener('click', () => { const result = calculateProbabilities(); if (result && result.data && result.data.length > 0) { frozenState.playground = result; updatePlaygroundChart(); updateAllButtonStates(); } });
            ui.playground_clear_button.addEventListener('click', () => {
                frozenState.playground = null;
                simulationResult.playground = null;
                updatePlaygroundChart();
                updateAllButtonStates();
            });
            
            // Attack Tab Listeners
            ['attack-bonus', 'target-ac', 'damage-dice', 'attacks-per-turn'].forEach(id => document.getElementById(id).addEventListener('input', calculateADPR));
            document.getElementById('adv-selector').addEventListener('change', calculateADPR);
            document.getElementById('chart-mode-selector').addEventListener('change', calculateADPR);
            ui.attack_future_button.addEventListener('click', simulateSingleAttack);
            ui.attack_freeze_button.addEventListener('click', () => {
                const params = getAttackParamsFromUI();
                frozenState.attack = { params: params }; 
                calculateADPR();
                updateAllButtonStates();
            });
            ui.attack_clear_button.addEventListener('click', () => { frozenState.attack = null; simulationResult.attack = null; ui.attack_sim_result.innerHTML = `<span class="placeholder">Awaiting a glimpse of the future...</span>`; calculateADPR(); updateAllButtonStates(); });

            // Save Tab Listeners
            ['save-dc', 'save-damage', 'target-save-bonus', 'num-targets'].forEach(id => document.getElementById(id).addEventListener('input', calculateSaveDamage));
            document.getElementById('save-adv-selector').addEventListener('change', calculateSaveDamage);
            document.getElementById('save-outcome-selector').addEventListener('change', calculateSaveDamage);
            ui.save_future_button.addEventListener('click', simulateSingleSave);
            ui.save_freeze_button.addEventListener('click', () => { 
                const result = getCurrentSaveDistribution();
                if(result) {
                    frozenState.save = result.distribution;
                    frozenState.save.params = {
                        damage: document.getElementById('save-damage').value,
                        dc: document.getElementById('save-dc').value,
                    };
                }
                calculateSaveDamage(); 
                updateAllButtonStates();
            });
            ui.save_clear_button.addEventListener('click', () => { frozenState.save = null; simulationResult.save = null; ui.save_sim_result.innerHTML = `<span class="placeholder">Awaiting a glimpse of the future...</span>`; calculateSaveDamage(); updateAllButtonStates(); });

            window.addEventListener('resize', () => { const activeTab = document.querySelector('.tab-content.active').id; if (activeTab === 'tab-1') updatePlaygroundChart(); if (activeTab === 'tab-2') calculateADPR(); if (activeTab === 'tab-3') calculateSaveDamage(); });
        }
        
        // --- UI STATE MANAGEMENT ---
        function updateAllButtonStates() {
            ui.playground_clear_button.disabled = !frozenState.playground;
            ui.attack_clear_button.disabled = !frozenState.attack;
            ui.save_clear_button.disabled = !frozenState.save;
        }

        // --- PERSISTENCE & PRESET FUNCTIONS ---
        function saveState() {
            const state = {
                activeTab: document.querySelector('.tab-content.active')?.id || 'tab-0',
                playground: playgroundState,
                attack: getAttackParamsFromUI(),
                save: {
                    'save-dc': document.getElementById('save-dc').value,
                    'save-damage': document.getElementById('save-damage').value,
                    'target-save-bonus': document.getElementById('target-save-bonus').value,
                    'save-advantage': document.querySelector('input[name="save-advantage"]:checked').value,
                    'save-outcome': document.querySelector('input[name="save-outcome"]:checked').value,
                    'num-targets': document.getElementById('num-targets').value,
                }
            };
            if(frozenState.attack) state.frozenAttack = frozenState.attack;
            if(frozenState.save) state.frozenSave = frozenState.save;
            try {
                localStorage.setItem(LS_LAST_STATE_KEY, JSON.stringify(state));
            } catch (e) {
                console.warn("Could not save state to localStorage:", e);
            }
        }

        function loadState() {
            let stateJSON;
            try {
                stateJSON = localStorage.getItem(LS_LAST_STATE_KEY);
            } catch (e) {
                console.warn("Could not read state from localStorage:", e);
                return;
            }
            
            if (!stateJSON) {
                 const buttonToClick = document.querySelector('.tab-button[data-tab="tab-0"]');
                 if (buttonToClick) {
                    buttonToClick.click();
                 }
                return;
            }

            try {
                const state = JSON.parse(stateJSON);
                
                if (state.playground) {
                    Object.assign(playgroundState, state.playground);
                    syncUiToState();
                }

                if (state.attack) {
                    document.getElementById('attack-bonus').value = state.attack['attack-bonus'] || '5';
                    document.getElementById('target-ac').value = state.attack['target-ac'] || '15';
                    document.getElementById('damage-dice').value = state.attack['damage-dice'] || '2d6+3';
                    document.getElementById('attacks-per-turn').value = state.attack['attacks-per-turn'] || '1';
                    const advState = state.attack.advState || '0';
                    document.querySelector(`input[name="advantage"][value="${advState}"]`).checked = true;
                    const chartMode = state.attack.chartMode || 'fixed';
                    document.querySelector(`input[name="chart-mode"][value="${chartMode}"]`).checked = true;
                }

                if(state.frozenAttack) frozenState.attack = state.frozenAttack;
                if(state.frozenSave) frozenState.save = state.frozenSave;
                
                if (state.save) {
                    for(const [id, value] of Object.entries(state.save)) {
                         if (id === 'save-advantage' || id === 'save-outcome') {
                            const radio = document.querySelector(`input[name="${id}"][value="${value}"]`);
                            if (radio) radio.checked = true;
                        } else {
                            const el = document.getElementById(id);
                            if (el) el.value = value;
                        }
                    }
                }

                const tabToLoad = state.activeTab || 'tab-0';
                const buttonToClick = document.querySelector(`.tab-button[data-tab="${tabToLoad}"]`);
                if (buttonToClick) {
                   buttonToClick.click();
                }

            } catch (e) {
                console.error("Failed to parse or apply saved state:", e);
                try {
                    localStorage.removeItem(LS_LAST_STATE_KEY);
                } catch (removeError) {
                    console.error("Could not remove broken state from localStorage", removeError);
                }
            }
        }
        
        function loadPresets() {
            let presetsJSON;
            try {
                presetsJSON = localStorage.getItem(LS_PRESETS_KEY);
            } catch (e) {
                console.warn("Could not read presets from localStorage", e);
                presetsJSON = null;
            }
            const userPresets = presetsJSON ? JSON.parse(presetsJSON) : {};
            presets = JSON.parse(JSON.stringify(DEFAULT_PRESETS));
            Object.assign(presets, userPresets);
            updatePresetUI();
        }
        
        function updatePresetUI() {
            document.querySelectorAll('.preset-select').forEach(select => {
                const tabId = select.closest('.preset-manager').dataset.tabId;
                const currentSelection = select.value;
                select.innerHTML = `<option value="">--- Load Preset ---</option>`;
                const defaultPresetsForTab = Object.keys(DEFAULT_PRESETS).filter(key => DEFAULT_PRESETS[key].tabId === tabId);
                const userPresetsForTab = Object.keys(presets).filter(key => presets[key].tabId === tabId && !DEFAULT_PRESETS.hasOwnProperty(key));
                if (defaultPresetsForTab.length > 0) {
                    const group = document.createElement('optgroup');
                    group.label = "Default Presets";
                    defaultPresetsForTab.sort().forEach(key => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = key;
                        group.appendChild(option);
                    });
                    select.appendChild(group);
                }
                if (userPresetsForTab.length > 0) {
                    const group = document.createElement('optgroup');
                    group.label = "Your Presets";
                    userPresetsForTab.sort().forEach(key => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = key;
                        group.appendChild(option);
                    });
                    select.appendChild(group);
                }
                if (select.querySelector(`option[value="${currentSelection}"]`)) {
                    select.value = currentSelection;
                }
            });
        }

        function savePreset(event) {
            const manager = event.target.closest('.preset-manager');
            const input = manager.querySelector('.preset-name-input');
            const saveButton = event.target;
            const presetName = input.value.trim();
            if (presetName === '') {
                input.classList.add('invalid');
                input.focus();
                setTimeout(() => input.classList.remove('invalid'), 1500);
                return;
            }
            if (DEFAULT_PRESETS.hasOwnProperty(presetName)) {
                input.classList.add('invalid');
                input.value = '';
                input.placeholder = "Cannot overwrite default!";
                setTimeout(() => { 
                    input.classList.remove('invalid');
                    input.placeholder = "New Preset Name";
                }, 2000);
                return;
            }
            const tabId = manager.dataset.tabId;
            let presetData = { tabId };
            if (tabId === 'tab-1') {
                presetData.state = JSON.parse(JSON.stringify(playgroundState));
            } else if (tabId === 'tab-2') {
                presetData.state = getAttackParamsFromUI();
            } else if (tabId === 'tab-3') {
                 presetData.state = {
                    'save-dc': document.getElementById('save-dc').value,
                    'save-damage': document.getElementById('save-damage').value,
                    'target-save-bonus': document.getElementById('target-save-bonus').value,
                    'save-advantage': document.querySelector('input[name="save-advantage"]:checked').value,
                    'save-outcome': document.querySelector('input[name="save-outcome"]:checked').value,
                    'num-targets': document.getElementById('num-targets').value,
                };
            }
            try {
                const presetsJSON = localStorage.getItem(LS_PRESETS_KEY);
                const userPresets = presetsJSON ? JSON.parse(presetsJSON) : {};
                userPresets[presetName] = presetData;
                localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(userPresets));
                loadPresets();
                input.value = '';
                const originalText = saveButton.textContent;
                saveButton.textContent = 'Saved!';
                saveButton.disabled = true;
                setTimeout(() => {
                    saveButton.textContent = originalText;
                    saveButton.disabled = false;
                }, 1500);
            } catch(e) {
                alert("Could not save preset. Your browser may be blocking localStorage.");
            }
        }

        function loadPreset(event) {
            const select = event.target;
            const presetName = select.value;
            if (!presetName || !presets[presetName]) return;
            const preset = presets[presetName];
            if (preset.tabId === 'tab-1') {
                for (const key in playgroundState) {
                    if (key !== 'meta') playgroundState[key] = { count: 0, dropLow: 0, dropHigh: 0 };
                }
                playgroundState.meta = { value: 0, dc: 0 };
                for (const key in preset.state) {
                     playgroundState[key] = { ...playgroundState[key], ...preset.state[key] };
                }
                syncUiToState();
                updatePlaygroundChart();
            } else if (preset.tabId === 'tab-2') {
                const state = preset.state;
                document.getElementById('attack-bonus').value = state['attack-bonus'];
                document.getElementById('target-ac').value = state['target-ac'];
                document.getElementById('damage-dice').value = state['damage-dice'];
                document.getElementById('attacks-per-turn').value = state['attacks-per-turn'];
                document.querySelector(`input[name="advantage"][value="${state.advState}"]`).checked = true;
                const chartMode = state.chartMode || 'fixed';
                document.querySelector(`input[name="chart-mode"][value="${chartMode}"]`).checked = true;
                calculateADPR();
            } else { // tab-3
                for(const [id, value] of Object.entries(preset.state)) {
                    const input = document.getElementById(id);
                    if (input) {
                        if (input.type === 'checkbox') {
                            input.checked = value;
                        } else {
                            input.value = value;
                        }
                        input.dispatchEvent(new Event('change', {bubbles: true}));
                        input.dispatchEvent(new Event('input', {bubbles: true}));
                    } else {
                        const radio = document.querySelector(`input[name="${id}"][value="${value}"]`);
                        if(radio) {
                            radio.checked = true;
                            radio.dispatchEvent(new Event('change', {bubbles: true}));
                        }
                    }
                }
            }
        }
        
        function deleteSelectedPreset(event) {
            const manager = event.target.closest('.preset-manager');
            const select = manager.querySelector('.preset-select');
            const deleteButton = event.target;
            const presetToDelete = select.value;
            if (!presetToDelete || DEFAULT_PRESETS.hasOwnProperty(presetToDelete)) return; 
            try {
                const presetsJSON = localStorage.getItem(LS_PRESETS_KEY);
                const userPresets = presetsJSON ? JSON.parse(presetsJSON) : {};
                delete userPresets[presetToDelete];
                localStorage.setItem(LS_PRESETS_KEY, JSON.stringify(userPresets));
                deleteButton.textContent = 'Deleted!';
                loadPresets();
                updateDeleteButtonState(manager);
            } catch(e) {
                alert("Could not delete preset. Your browser may be blocking localStorage.");
            }
        }

        function updateDeleteButtonState(manager) {
            const select = manager.querySelector('.preset-select');
            const deleteButton = manager.querySelector('.btn-delete');
            const presetToActOn = select.value;
            if (presetToActOn && !DEFAULT_PRESETS.hasOwnProperty(presetToActOn)) {
                deleteButton.disabled = false;
                deleteButton.textContent = `Delete '${presetToActOn}'`;
            } else {
                deleteButton.disabled = true;
                if (presetToActOn && DEFAULT_PRESETS.hasOwnProperty(presetToActOn)) {
                    deleteButton.textContent = 'Cannot Delete Default';
                } else {
                    deleteButton.textContent = 'Delete Selected';
                }
            }
        }

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }
        
        // --- CALCULATION ENGINE ---
        function parseDamageString(str) {
            const result = { groups: [], mod: 0, error: false };
            if (!str || typeof str !== 'string' || str.trim() === '') return result;

            const normalizedStr = str.trim().replace(/\s/g, '').replace(/([+-])/g, ' $1 ');
            const parts = normalizedStr.split(' ');
            let currentOperator = '+';

            for (const part of parts) {
                if (part === '+' || part === '-') {
                    currentOperator = part;
                    continue;
                }
                const sign = currentOperator === '+' ? 1 : -1;
                const dieMatch = part.match(/^(\d*)[dD](\d+)$/);
                if (dieMatch) {
                    const count = dieMatch[1] === '' ? 1 : parseInt(dieMatch[1]);
                    result.groups.push({ count: count * sign, sides: parseInt(dieMatch[2]) });
                    continue;
                }
                const numMatch = part.match(/^\d+$/);
                if (numMatch) {
                    result.mod += parseInt(part) * sign;
                    continue;
                }
                result.error = true;
                return result;
            }
            return result;
        }
        
        function getDiceDistribution(damageData) {
            const { groups, mod } = damageData;
            if (!groups || groups.length === 0) {
                return { data: [{ value: mod, probability: 1 }], type: 'Constant' };
            }

            let finalDistribution = { data: [{ value: 0, probability: 1 }], type: 'Exact' };

            groups.forEach(group => {
                const absCount = Math.abs(group.count);
                if (absCount === 0) return;

                const singleDieDist = { data: [], type: 'Exact' };
                for (let i = 1; i <= group.sides; i++) {
                    const rollValue = group.count > 0 ? i : -i;
                    singleDieDist.data.push({ value: rollValue, probability: 1 / group.sides });
                }

                let groupDistribution = { data: [{ value: 0, probability: 1 }], type: 'Exact' };
                for (let i = 0; i < absCount; i++) {
                    groupDistribution = convolveDistributions(groupDistribution, singleDieDist);
                }
                finalDistribution = convolveDistributions(finalDistribution, groupDistribution);
            });
            
            finalDistribution.data.forEach(d => d.value += mod);
            return finalDistribution;
        }
        
        // --- DICE PLAYGROUND (TAB 1) ---
        function initializeDicePlayground() { diceTypes.forEach(s => createDieControl(`d${s}`)); createDieControl('meta'); syncUiToState(); updatePlaygroundChart(); }
        function createDieControl(key) { const isMeta = key === 'meta'; playgroundState[key] = isMeta ? { value: 0, dc: 0 } : { count: 0, dropLow: 0, dropHigh: 0 }; const label = isMeta ? "Bonuses" : `D${key.substring(1)}`; const icon = diceIcons[isMeta ? 'meta' : parseInt(key.substring(1))]; const metaControlsHTML = `<div class="control-row"><span>Modifier</span><div class="count-controls"><button class="btn-adjust" data-action="decrease">-</button><input type="number" class="die-input" data-type="value" value="0"><button class="btn-adjust" data-action="increase">+</button></div></div><div class="control-row"><span>DC</span><div class="count-controls"><button class="btn-adjust" data-action="decrease">-</button><input type="number" class="die-input" data-type="dc" value="0"><button class="btn-adjust" data-action="increase">+</button></div></div>`; const dieControlsHTML = `<div class="control-row"><span>Count</span><div class="count-controls"><button class="btn-adjust" data-action="decrease">-</button><input type="number" class="die-input" data-type="count" value="0"><button class="btn-adjust" data-action="increase">+</button></div></div><div class="control-row"><span class="label-drop-low">Drop Lowest</span><div class="count-controls"><button class="btn-adjust" data-action="decrease">-</button><input type="number" class="die-input" data-type="dropLow" value="0"><button class="btn-adjust" data-action="increase">+</button></div></div><div class="control-row"><span class="label-drop-high">Drop Highest</span><div class="count-controls"><button class="btn-adjust" data-action="decrease">-</button><input type="number" class="die-input" data-type="dropHigh" value="0"><button class="btn-adjust" data-action="increase">+</button></div></div>`; ui.roll_builder.insertAdjacentHTML('beforeend', `<div class="die-control" data-key="${key}"><div class="die-header">${icon}<span class="die-label">${label}</span></div><div class="controls-wrapper">${isMeta ? metaControlsHTML : dieControlsHTML}</div></div>`); }
        function getSingleRollResult(withDetails = false) { let grandTotal = 0; const detailParts = []; for (const key in playgroundState) { if (key === 'meta' || playgroundState[key].count === 0) continue; const { count, dropLow, dropHigh } = playgroundState[key]; const sides = parseInt(key.substring(1)); const isNegative = count < 0; const rollCount = Math.abs(count); const keptCount = rollCount - dropLow - dropHigh; if (keptCount <= 0) { if (withDetails) detailParts.push(`<b>${count}D${sides}</b>: All dice dropped!`); continue; } const rolls = Array.from({ length: rollCount }, () => Math.floor(Math.random() * sides) + 1); const keptRolls = (dropLow > 0 || dropHigh > 0) ? [...rolls].sort((a,b)=>a-b).slice(dropLow, rollCount - dropHigh) : rolls; let subTotal = keptRolls.reduce((sum, roll) => sum + roll, 0); if (isNegative) subTotal *= -1; grandTotal += subTotal; if (withDetails) { let detail = `<b>${count}D${sides}</b>: [${rolls.join(', ')}]`; if (dropLow > 0 || dropHigh > 0) { detail += `  Kept [${keptRolls.join(', ')}]`; } detail += ` = ${subTotal}`; detailParts.push(detail); } } grandTotal += playgroundState.meta.value; if (withDetails) { if (playgroundState.meta.value !== 0) detailParts.push(`<b>Modifier</b>: ${playgroundState.meta.value > 0 ? '+' : ''}${playgroundState.meta.value}`); return { grandTotal, detailParts }; } return grandTotal; }
        function handleRoll() { const { grandTotal, detailParts } = getSingleRollResult(true); if (detailParts.length === 0 && playgroundState.meta.value === 0) { ui.result_total.textContent = '0'; ui.result_details.innerHTML = 'Nothing to roll!'; ui.result_status.innerHTML = ''; } else { ui.result_total.textContent = grandTotal; ui.result_details.innerHTML = detailParts.join('<br>'); } ui.result_total.classList.remove('placeholder'); const dc = playgroundState.meta.dc; if (dc > 0) { if (grandTotal >= dc) { ui.result_status.innerHTML = `<span class="success">Success!</span>`; } else { ui.result_status.innerHTML = `<span class="failure">Failure</span>`; } } else { ui.result_status.innerHTML = ''; } simulationResult.playground = grandTotal; updatePlaygroundChart(); }
        function updatePlaygroundChart() {
            ui.playground_chart_container.innerHTML = `<p class="chart-message">Consulting the ether...</p>`;
            ui.playground_chart_info.innerHTML = '';
            setTimeout(() => {
                const result = calculateProbabilities();
                let infoText = '';
                
                const currentStats = getStatsFromDistribution(result);
                if (currentStats) {
                    infoText += `<span class="current-info-text">Current - Range: ${currentStats.min} to ${currentStats.max} | Average: ${currentStats.average.toFixed(2)}</span>`;
                }

                const frozenStats = getStatsFromDistribution(frozenState.playground);
                if (frozenStats) {
                    if (infoText) infoText += '<br>';
                    infoText += `<span class="frozen-info-text">Alternate - Range: ${frozenStats.min} to ${frozenStats.max} | Average: ${frozenStats.average.toFixed(2)}</span>`;
                }
                
                let subtitle = '';
                if (hasData(result)) subtitle += `<tspan class="current-subtitle-text">Current: ${result.type}</tspan>`;
                if (hasData(frozenState.playground)) {
                    if (subtitle) subtitle += ' | ';
                    subtitle += `<tspan class="frozen-subtitle-text">Alternate: ${frozenState.playground.type}</tspan>`;
                }

                const chartOptions = { data: result, frozenData: frozenState.playground, rollResult: simulationResult.playground, dc: playgroundState.meta.dc, xAxisLabel: 'Sum', yAxisLabel: 'Probability', yAxisFormat: 'percent', infoText, subtitle, isCalculatorChart: false };
                drawDistributionChart(ui.playground_chart_container, ui.playground_chart_info, chartOptions);
            }, 10);
        }
        function calculateProbabilities() { const hasNegative = Object.values(playgroundState).some(s => typeof s === 'object' && s.count < 0); const dropActive = Object.values(playgroundState).some(s => typeof s === 'object' && (s.dropLow > 0 || s.dropHigh > 0)); if (dropActive || hasNegative) { const combinations = Object.entries(playgroundState).filter(([k, v]) => k !== 'meta' && v.count !== 0).reduce((acc, [k, v]) => acc * Math.pow(parseInt(k.substring(1)), Math.abs(v.count)), 1); if (combinations > BRUTE_FORCE_LIMIT) { return calculateProbabilitiesSimulation(); } else { return calculateProbabilitiesBruteForce(); } } else { return calculateProbabilitiesConvolution(); } }
        function calculateProbabilitiesConvolution() { let counts = { 0: 1 }; let totalDice = 0; for (const key in playgroundState) { if (key === 'meta' || playgroundState[key].count === 0) continue; const { count, sides } = { count: playgroundState[key].count, sides: parseInt(key.substring(1)) }; totalDice += Math.abs(count); for (let i = 0; i < Math.abs(count); i++) { const newCounts = {}; for (const sum in counts) { for (let roll = 1; roll <= sides; roll++) { const rollValue = count > 0 ? roll : -roll; const newSum = parseInt(sum) + rollValue; newCounts[newSum] = (newCounts[newSum] || 0) + counts[sum]; } } counts = newCounts; } } if (totalDice === 0) return { data: null }; const totalCombinations = Object.values(counts).reduce((a, b) => a + b, 0); const data = Object.entries(counts).map(([sum, count]) => ({ value: parseInt(sum) + playgroundState.meta.value, probability: count / totalCombinations })); return { data, type: 'Exact' }; }
        function calculateProbabilitiesBruteForce() { const diceGroups = Object.entries(playgroundState).filter(([k,v])=>k!=='meta'&&v.count!==0).map(([k,v])=>({...v, sides:parseInt(k.substring(1))})); if (diceGroups.length === 0) return {data:null}; const sumCounts = {}; let totalCombinations = 0; function recurse(groupIndex, currentSum) { if (groupIndex === diceGroups.length) { sumCounts[currentSum] = (sumCounts[currentSum] || 0) + 1; totalCombinations++; return; } const group = diceGroups[groupIndex]; const rollCount = Math.abs(group.count); function generateGroupRolls(dieIndex, rolls) { if (dieIndex === rollCount) { const kept = [...rolls].sort((a,b)=>a-b).slice(group.dropLow, rollCount - group.dropHigh); let subTotal = kept.reduce((a, b) => a + b, 0); if (group.count < 0) subTotal *= -1; recurse(groupIndex + 1, currentSum + subTotal); return; } for (let i = 1; i <= group.sides; i++) { generateGroupRolls(dieIndex + 1, [...rolls, i]); } } generateGroupRolls(0, []); } recurse(0, playgroundState.meta.value); return { data: Object.entries(sumCounts).map(([sum,count])=>({value:parseInt(sum), probability:count/totalCombinations})), type:'Exact' }; }
        function calculateProbabilitiesSimulation() { const sumCounts = {}; for (let i = 0; i < SIMULATION_COUNT; i++) { const result = getSingleRollResult(); sumCounts[result] = (sumCounts[result] || 0) + 1; } let data = Object.entries(sumCounts).map(([sum, count]) => ({ value: parseInt(sum), probability: count / SIMULATION_COUNT })); data.sort((a, b) => a.value - b.value); const fullRangeData = []; if (data.length > 0) { const min = data[0].value; const max = data[data.length - 1].value; let dataIndex = 0; for (let i = min; i <= max; i++) { if (data[dataIndex] && data[dataIndex].value === i) { fullRangeData.push(data[dataIndex]); dataIndex++; } else { fullRangeData.push({ value: i, probability: 0 }); } } } const smoothedData = fullRangeData.map((point, i, arr) => { const p_im1 = arr[i - 1] ? arr[i - 1].probability : point.probability; const p_ip1 = arr[i + 1] ? arr[i + 1].probability : point.probability; return { value: point.value, probability: (p_im1 + point.probability + p_ip1) / 3 }; }); return { data: smoothedData, type: `Estimated (${(SIMULATION_COUNT/1000)}k sims, smoothed)` }; }
        
        // --- ATTACK & SAVE CALCULATORS ---
        function calculateADPR() {
            const chartMode = document.querySelector('input[name="chart-mode"]:checked').value;
            const targetAcInput = document.getElementById('target-ac');
            const chartTitle = ui.attack_chart_title;

            if (chartMode === 'fixed') {
                targetAcInput.disabled = false;
                chartTitle.textContent = 'Average Damage Distribution';
                renderFixedAcChart();
            } else { // 'variable'
                targetAcInput.disabled = true;
                chartTitle.textContent = 'Average Damage vs. Target AC';
                renderVariableAcChart();
            }
        }

        function renderFixedAcChart() {
            const currentParams = getAttackParamsFromUI();
            updateAdprSummary(currentParams, currentParams.targetAC);
            const fullDistribution = getFullAttackDistribution(currentParams);
            if (!fullDistribution) return;

            let frozenDistributionForChart = null;
            if (frozenState.attack && frozenState.attack.params) {
                const frozenResult = getFullAttackDistribution(frozenState.attack.params);
                if (frozenResult) frozenDistributionForChart = frozenResult.distribution;
            }

            let infoText = '';
            const currentStats = getStatsFromDistribution(fullDistribution.distribution);
            if(currentStats) { infoText += `<span class="current-info-text">Current - Range: ${currentStats.min} to ${currentStats.max} | Average: ${currentStats.average.toFixed(2)}</span>`; }
            
            const frozenStats = getStatsFromDistribution(frozenDistributionForChart);
            if (frozenStats) { if (infoText) infoText += '<br>'; infoText += `<span class="frozen-info-text">Alternate - Range: ${frozenStats.min} to ${frozenStats.max} | Average: ${frozenStats.average.toFixed(2)}</span>`; }
            
            const buildLabel = p => `${p.damageDice}, +${p.atkBonus} bonus`;
            let subtitle = `<tspan class="current-subtitle-text">Current: ${buildLabel(currentParams)}</tspan>`;
            if (frozenState.attack && frozenState.attack.params) {
                subtitle += ` | <tspan class="frozen-subtitle-text">Alternate: ${buildLabel(frozenState.attack.params)}</tspan>`;
            }

            const chartOptions = { data: fullDistribution.distribution, frozenData: frozenDistributionForChart, rollResult: simulationResult.attack, xAxisLabel: 'Total Damage', yAxisLabel: 'Probability', yAxisFormat: 'percent', infoText, subtitle, isCalculatorChart: true };
            drawDistributionChart(ui.adpr_chart_container, ui.adpr_chart_info, chartOptions);
        }

        function renderVariableAcChart() {
            const currentParams = getAttackParamsFromUI();
            updateAdprSummary(currentParams, parseInt(document.getElementById('target-ac').value));

            const calculateLine = (params) => {
                const singleAttackResult = getSingleAttackDistribution(params);
                if (!singleAttackResult) return null;

                const lineData = [];
                for (let ac = 5; ac <= 30; ac++) {
                    const adpr = calculateAdprForAc(params, ac);
                    lineData.push({ value: ac, probability: adpr });
                }
                return { data: lineData, type: 'ADPR vs AC' };
            };

            const currentChartData = calculateLine(currentParams);
            if (!currentChartData) return;

            let frozenChartData = null;
            if (frozenState.attack && frozenState.attack.params) {
                frozenChartData = calculateLine(frozenState.attack.params);
            }
            
            const buildLabel = p => `${p.damageDice}, +${p.atkBonus} bonus`;
            let subtitle = `<tspan class="current-subtitle-text">Current: ${buildLabel(currentParams)}</tspan>`;
            if (frozenState.attack && frozenState.attack.params) {
                subtitle += ` | <tspan class="frozen-subtitle-text">Alternate: ${buildLabel(frozenState.attack.params)}</tspan>`;
            }

            const chartOptions = { data: currentChartData, frozenData: frozenChartData, xAxisLabel: 'Target AC', yAxisLabel: 'Average Damage', yAxisFormat: 'number', infoText: '', subtitle, isCalculatorChart: false };
            drawDistributionChart(ui.adpr_chart_container, ui.adpr_chart_info, chartOptions);
        }

        function updateAdprSummary(params, referenceAc) {
            const singleAttackResult = getSingleAttackDistribution({ ...params, targetAC: referenceAc });
            
            const errorDisplay = document.getElementById('adpr-error');

            if (!singleAttackResult) {
                document.getElementById('adpr-total').textContent = 'Error';
                ['crit-chance', 'hit-chance', 'miss-chance', 'avg-damage', 'avg-crit-damage'].forEach(id => {
                    document.getElementById(id).textContent = '---';
                });
                return;
            }
            
            const { summary } = singleAttackResult;
            const totalAdpr = summary.adpr * params.numAttacks;

            document.getElementById('adpr-total').textContent = totalAdpr.toFixed(2);
            document.getElementById('crit-chance').textContent = `${(summary.critChance * 100).toFixed(1)}%`;
            document.getElementById('hit-chance').textContent = `${(summary.hitChance * 100).toFixed(1)}%`;
            document.getElementById('miss-chance').textContent = `${(summary.missChance * 100).toFixed(1)}%`;
            document.getElementById('avg-damage').textContent = summary.avgDamage.toFixed(1);
            document.getElementById('avg-crit-damage').textContent = summary.avgCritDamage.toFixed(1);
            errorDisplay.textContent = '';
            document.getElementById('attack-bonus').classList.remove('invalid');
            document.getElementById('damage-dice').classList.remove('invalid');
        }

        function calculateAdprForAc(params, ac) {
            const singleAttackResult = getSingleAttackDistribution({ ...params, targetAC: ac });
            if (!singleAttackResult) return 0;
            return singleAttackResult.summary.adpr * params.numAttacks;
        }

        function getAttackParamsFromUI() {
            return {
                atkBonus: document.getElementById('attack-bonus').value || '0', 
                targetAC: parseInt(document.getElementById('target-ac').value) || 0,
                damageDice: document.getElementById('damage-dice').value,
                numAttacks: parseInt(document.getElementById('attacks-per-turn').value) || 1,
                advState: parseInt(document.querySelector('input[name="advantage"]:checked').value),
                chartMode: document.querySelector('input[name="chart-mode"]:checked')?.value || 'fixed',
            };
        }

        function getFullAttackDistribution(params) {
            const singleAttackDist = getSingleAttackDistribution(params);
            if (!singleAttackDist) return null;

            let combinedDist = singleAttackDist.distribution;
            for (let i = 1; i < params.numAttacks; i++) {
                combinedDist = convolveDistributions(combinedDist, singleAttackDist.distribution);
            }
            
            const totalAdpr = singleAttackDist.summary.adpr * params.numAttacks;
            return {
                summary: { ...singleAttackDist.summary, adpr: totalAdpr },
                distribution: combinedDist
            };
        }

        function getSingleAttackDistribution(params) {
            const { atkBonus, targetAC, damageDice, advState } = params;
            const errorDisplay = document.getElementById('adpr-error'); 
            
            const damageData = parseDamageString(damageDice); 
            const atkBonusData = parseDamageString(String(atkBonus));

            const totalDice = (damageData.groups.reduce((a,g) => a + Math.abs(g.count), 0)) + 
                              (atkBonusData.groups.reduce((a,g) => a + Math.abs(g.count), 0));

            if (totalDice > CALCULATOR_DICE_LIMIT) {
                errorDisplay.textContent = `Calculation too complex. Max ${CALCULATOR_DICE_LIMIT} dice.`;
                ui.adpr_chart_container.innerHTML = `<p class="chart-message">Calculation Too Complex</p>`;
                ui.adpr_chart_info.innerHTML = '';
                return null;
            }

            let hasError = false;
            let errorMessage = '';
            if (damageData.error) {
                document.getElementById('damage-dice').classList.add('invalid');
                errorMessage += 'Invalid Damage format. ';
                hasError = true;
            }
            if (atkBonusData.error) {
                document.getElementById('attack-bonus').classList.add('invalid');
                errorMessage += 'Invalid Attack Bonus format.';
                hasError = true;
            }

            if (hasError) {
                errorDisplay.textContent = errorMessage.trim();
                ui.adpr_chart_container.innerHTML = `<p class="chart-message">Invalid formula.</p>`;
                ui.adpr_chart_info.innerHTML = ''; 
                return null;
            }

            const { groups, mod } = damageData; 
            const avgDamage = groups.reduce((sum, g) => sum + Math.abs(g.count) * ((g.sides + 1) / 2), 0) + mod;
            const avgCritDamage = groups.reduce((sum, g) => sum + Math.abs(g.count) * 2 * ((g.sides + 1) / 2), 0) + mod;
            
            const bonusDistribution = getDiceDistribution(atkBonusData);
            let totalCritChance = 0;
            let totalHitChance = 0;
            let totalMissChance = 0;

            for (const bonusOutcome of bonusDistribution.data) {
                const currentBonus = bonusOutcome.value;
                const probability = bonusOutcome.probability;
                const rollToHit = Math.max(2, Math.min(20, targetAC - currentBonus)); 
                let critChance_i = 0, missChance_i = 0; 
                if (advState === 0) { critChance_i = 1 / 20; missChance_i = Math.min(19/20, (rollToHit - 1) / 20); } 
                else if (advState === 1) { critChance_i = 1 - (19/20)**2; missChance_i = ((rollToHit - 1) / 20)**2; } 
                else { critChance_i = (1/20)**2; missChance_i = 1 - ((20 - rollToHit + 1) / 20)**2; } 
                if (rollToHit <= 1) { missChance_i = (advState === 1) ? (1/20)**2 : (advState === -1) ? (1 - (19/20)**2) : 1/20; }
                critChance_i = Math.max(0, critChance_i); 
                missChance_i = Math.max(0, missChance_i); 
                let hitChance_i = Math.max(0, 1 - critChance_i - missChance_i); 
                totalCritChance += critChance_i * probability;
                totalHitChance += hitChance_i * probability;
                totalMissChance += missChance_i * probability;
            }

            const adpr = (totalHitChance * avgDamage) + (totalCritChance * avgCritDamage); 
            const damageDist = getDiceDistribution(damageData);
            const critDamageData = { 
                groups: groups.map(g => ({...g, count: g.count * 2})), 
                mod: mod 
            };
            const critDamageDist = getDiceDistribution(critDamageData);
            
            const finalDist = {};
            damageDist.data.forEach(d => { finalDist[d.value] = (finalDist[d.value] || 0) + d.probability * totalHitChance; });
            critDamageDist.data.forEach(d => { finalDist[d.value] = (finalDist[d.value] || 0) + d.probability * totalCritChance; });
            finalDist[0] = (finalDist[0] || 0) + totalMissChance;

            const chartData = { data: Object.entries(finalDist).map(([val, prob]) => ({ value: parseInt(val), probability: prob })) };
            return { distribution: chartData, summary: { adpr, critChance: totalCritChance, hitChance: totalHitChance, missChance: totalMissChance, avgDamage, avgCritDamage } };
        }

        // --- SAVE CALCULATOR (TAB 3) ---
        function calculateSaveDamage() {
            const result = getCurrentSaveDistribution();
            if (!result) return;
            
            const { distribution, summary } = result;
            const { totalAvgDamage, successChance, failChance, avgFailDamage, avgSuccessDamage } = summary;

            document.getElementById('save-total-damage').textContent = totalAvgDamage.toFixed(2); 
            document.getElementById('save-success-chance').textContent = `${(successChance * 100).toFixed(1)}%`; 
            document.getElementById('save-fail-chance').textContent = `${(failChance * 100).toFixed(1)}%`; 
            document.getElementById('save-fail-dmg').textContent = avgFailDamage.toFixed(1); 
            document.getElementById('save-success-dmg').textContent = avgSuccessDamage.toFixed(1);
            
            let infoText = '';
            const currentStats = getStatsFromDistribution(distribution);
            if(currentStats) { infoText += `<span class="current-info-text">Current - Range: ${currentStats.min} to ${currentStats.max} | Average: ${currentStats.average.toFixed(2)}</span>`; }
            const frozenStats = getStatsFromDistribution(frozenState.save);
            if (frozenStats) { if (infoText) infoText += '<br>'; infoText += `<span class="frozen-info-text">Alternate - Range: ${frozenStats.min} to ${frozenStats.max} | Average: ${frozenStats.average.toFixed(2)}</span>`; }

            const currentSaveParams = {
                damage: document.getElementById('save-damage').value,
                dc: document.getElementById('save-dc').value
            };
            const buildLabel = p => `${p.damage}, DC ${p.dc}`;
            let subtitle = `<tspan class="current-subtitle-text">Current: ${buildLabel(currentSaveParams)}</tspan>`;
            if (frozenState.save && frozenState.save.params) {
                subtitle += ` | <tspan class="frozen-subtitle-text">Alternate: ${buildLabel(frozenState.save.params)}</tspan>`;
            }

            const chartOptions = { data: distribution, frozenData: frozenState.save, rollResult: simulationResult.save, xAxisLabel: 'Total Damage', yAxisLabel: 'Probability', yAxisFormat: 'percent', infoText, subtitle, isCalculatorChart: true };
            drawDistributionChart(ui.save_chart_container, ui.save_chart_info, chartOptions);
        }

        function getCurrentSaveDistribution() {
            const damageInput = document.getElementById('save-damage'); 
            const saveBonusInput = document.getElementById('target-save-bonus');
            const errorDisplay = document.getElementById('save-error'); 
            
            const damageData = parseDamageString(damageInput.value); 
            const saveBonusData = parseDamageString(saveBonusInput.value);

            const totalDice = (damageData.groups.reduce((a,g) => a + Math.abs(g.count), 0)) + 
                              (saveBonusData.groups.reduce((a,g) => a + Math.abs(g.count), 0));
            
            if (totalDice > CALCULATOR_DICE_LIMIT) {
                errorDisplay.textContent = `Calculation too complex. Max ${CALCULATOR_DICE_LIMIT} dice.`;
                ui.save_chart_container.innerHTML = `<p class="chart-message">Calculation Too Complex</p>`;
                ui.save_chart_info.innerHTML = '';
                return null;
            }

            let hasError = false;
            let errorMessage = '';
            if (damageData.error) {
                damageInput.classList.add('invalid');
                errorMessage += 'Invalid Damage format. ';
                hasError = true;
            } else {
                damageInput.classList.remove('invalid');
            }
            if (saveBonusData.error) {
                saveBonusInput.classList.add('invalid');
                errorMessage += 'Invalid Save Bonus format.';
                hasError = true;
            } else {
                saveBonusInput.classList.remove('invalid');
            }

            if (hasError) {
                errorDisplay.textContent = errorMessage.trim();
                ui.save_chart_container.innerHTML = `<p class="chart-message">Invalid formula.</p>`; 
                ui.save_chart_info.innerHTML = ''; 
                return null;
            }
            errorDisplay.textContent = ''; 

            const { groups, mod } = damageData; 
            const saveDC = parseInt(document.getElementById('save-dc').value) || 0; 
            const advState = parseInt(document.querySelector('input[name="save-advantage"]:checked').value); 
            const saveOutcome = parseFloat(document.querySelector('input[name="save-outcome"]:checked').value); 
            const numTargets = parseInt(document.getElementById('num-targets').value) || 1; 

            const avgFailDamage = groups.reduce((sum, g) => sum + Math.abs(g.count) * ((g.sides + 1) / 2), 0) + mod;
            const avgSuccessDamage = avgFailDamage * saveOutcome; 
            
            const saveBonusDistribution = getDiceDistribution(saveBonusData);
            let totalSuccessChance = 0;

            for (const bonusOutcome of saveBonusDistribution.data) {
                const currentBonus = bonusOutcome.value;
                const probability = bonusOutcome.probability;
                const rollToSucceed = Math.max(1, Math.min(21, saveDC - currentBonus)); 
                let successChance_i = 0; 
                if (advState === 0) { successChance_i = (21 - rollToSucceed) / 20; } 
                else if (advState === 1) { successChance_i = 1 - ((rollToSucceed - 1) / 20)**2; } 
                else { successChance_i = ((21 - rollToSucceed) / 20)**2; } 
                successChance_i = Math.max(0, Math.min(1, successChance_i)); 
                totalSuccessChance += successChance_i * probability;
            }

            const failChance = 1 - totalSuccessChance; 
            const totalAvgDamage = numTargets * ((failChance * avgFailDamage) + (totalSuccessChance * avgSuccessDamage)); 
            
            const damageDist = getDiceDistribution(damageData);
            const singleTargetFinalDist = {};
            damageDist.data.forEach(d => { 
                const failDamage = d.value;
                const failProb = d.probability * failChance;
                singleTargetFinalDist[failDamage] = (singleTargetFinalDist[failDamage] || 0) + failProb;

                const successDmg = Math.floor(d.value * saveOutcome); 
                const successProb = d.probability * totalSuccessChance;
                singleTargetFinalDist[successDmg] = (singleTargetFinalDist[successDmg] || 0) + successProb;
            });

            const singleTargetChartData = {
                data: Object.entries(singleTargetFinalDist).map(([val, prob]) => ({ value: parseInt(val), probability: prob })),
            };

            let combinedDist = singleTargetChartData;
            for (let i = 1; i < numTargets; i++) {
                combinedDist = convolveDistributions(combinedDist, singleTargetChartData);
            }

            return { 
                distribution: combinedDist,
                summary: { totalAvgDamage, successChance: totalSuccessChance, failChance, avgFailDamage, avgSuccessDamage } 
            };
        }

        // --- SIMULATION FUNCTIONS ---
        function simulateSingleAttack() {
            const params = getAttackParamsFromUI();
            const damageData = parseDamageString(params.damageDice);
            const atkBonusData = parseDamageString(String(params.atkBonus));

            if (damageData.error || atkBonusData.error) {
                ui.attack_sim_result.innerHTML = `<span class="failure">Invalid formula in inputs.</span>`;
                return;
            }
            
            let grandTotalDamage = 0;
            const resultParts = [];

            for (let i = 0; i < params.numAttacks; i++) {
                let d20roll1 = Math.ceil(Math.random() * 20);
                let d20roll2 = Math.ceil(Math.random() * 20);
                let finalRoll = d20roll1;
                let rollDetail = `d20: ${d20roll1}`;
                if (params.advState === 1) { finalRoll = Math.max(d20roll1, d20roll2); rollDetail = `d20(Adv): [${d20roll1},${d20roll2}]${finalRoll}`; }
                if (params.advState === -1) { finalRoll = Math.min(d20roll1, d20roll2); rollDetail = `d20(Dis): [${d20roll1},${d20roll2}]${finalRoll}`; }
                
                const { total: rolledBonus, detail: bonusDetail } = getDiceRoll(atkBonusData);
                const bonusString = (rolledBonus >= 0) ? `+${bonusDetail}` : `${bonusDetail}`;

                let attackResult;
                let damage = 0;
                if (finalRoll === 1) {
                    attackResult = `<span class="failure">Crit Miss!</span> (0 dmg)`;
                    damage = 0;
                } else if (finalRoll === 20) {
                    const critDamageData = { 
                        groups: damageData.groups.map(g => ({...g, count: g.count * 2})), 
                        mod: damageData.mod 
                    };
                    const { total: dmg, detail } = getDiceRoll(critDamageData);
                    attackResult = `<span class="success">Crit Hit!</span> (${detail}=${dmg} dmg)`;
                    damage = dmg;
                } else if (finalRoll + rolledBonus >= params.targetAC) {
                    const { total: dmg, detail } = getDiceRoll(damageData);
                    attackResult = `<span class="success">Hit!</span> (${detail}=${dmg} dmg)`;
                    damage = dmg;
                } else {
                    attackResult = `<span class="failure">Miss!</span> (0 dmg)`;
                    damage = 0;
                }
                
                resultParts.push(`Attack ${i+1}: ${rollDetail}${bonusString} vs AC ${params.targetAC}  ${attackResult}`);
                grandTotalDamage += damage;
            }

            let finalHtml = resultParts.join('<br>');
            if (params.numAttacks > 1) {
                finalHtml += `<hr><b>Total Damage: ${grandTotalDamage}</b>`;
            }
            
            ui.attack_sim_result.innerHTML = finalHtml;
            simulationResult.attack = grandTotalDamage;
            calculateADPR();
        }
        
        function simulateSingleSave() {
            const damageData = parseDamageString(document.getElementById('save-damage').value);
            const saveBonusData = parseDamageString(document.getElementById('target-save-bonus').value);

            if (damageData.error || saveBonusData.error) {
                ui.save_sim_result.innerHTML = `<span class="failure">Invalid formula in inputs.</span>`;
                return;
            }

            const saveDC = parseInt(document.getElementById('save-dc').value) || 0; 
            const advState = parseInt(document.querySelector('input[name="save-advantage"]:checked').value); 
            const saveOutcome = parseFloat(document.querySelector('input[name="save-outcome"]:checked').value);
            const numTargets = parseInt(document.getElementById('num-targets').value) || 1;

            let grandTotalDamage = 0;
            const resultParts = [];

            for (let i = 0; i < numTargets; i++) {
                let d20roll1 = Math.ceil(Math.random() * 20);
                let d20roll2 = Math.ceil(Math.random() * 20);
                let finalRoll = d20roll1;
                let rollDetail = `d20 Roll: ${d20roll1}`;
                if (advState === 1) { finalRoll = Math.max(d20roll1, d20roll2); rollDetail = `d20 (Adv): [${d20roll1}, ${d20roll2}]  ${finalRoll}`; }
                if (advState === -1) { finalRoll = Math.min(d20roll1, d20roll2); rollDetail = `d20 (Dis): [${d20roll1}, ${d20roll2}]  ${finalRoll}`; }
                
                const { total: rolledSaveBonus, detail: saveBonusDetail } = getDiceRoll(saveBonusData);
                const { total: fullDmg, detail: dmgDetail } = getDiceRoll(damageData);
                
                let resultText;
                let damageTaken = 0;
                if (finalRoll + rolledSaveBonus >= saveDC) {
                    damageTaken = Math.floor(fullDmg * saveOutcome);
                    resultText = `Target ${i+1} (${rollDetail}+${saveBonusDetail} vs DC ${saveDC})  <span class="success">Success!</span> Damage: ${fullDmg}*${saveOutcome} = ${damageTaken}.`;
                } else {
                    damageTaken = fullDmg;
                    resultText = `Target ${i+1} (${rollDetail}+${saveBonusDetail} vs DC ${saveDC})  <span class="failure">Failure!</span> Damage: ${dmgDetail} = ${damageTaken}.`;
                }
                resultParts.push(resultText);
                grandTotalDamage += damageTaken;
            }

            let finalHtml = resultParts.join('<br>');
            if (numTargets > 1) {
                finalHtml += `<hr><b>Total Damage: ${grandTotalDamage}</b>`;
            }

            ui.save_sim_result.innerHTML = finalHtml;
            simulationResult.save = grandTotalDamage;
            calculateSaveDamage();
        }

        // --- UTILITY & HELPER FUNCTIONS ---
        function hasData(result) { return result && result.data && result.data.length > 0; }
        function getStatsFromDistribution(distribution) {
            if (!hasData(distribution)) return null;
            const data = distribution.data;
            const values = data.map(d => d.value);
            const min = Math.min(...values);
            const max = Math.max(...values);
            const average = data.reduce((acc, p) => acc + p.value * p.probability, 0);
            return { min, max, average };
        }
        function getDiceRoll(damageData) {
            const { groups, mod } = damageData;
            if (groups.length === 0) return { total: mod, detail: `${mod}` };
            
            let total = mod;
            let detailParts = [];

            groups.forEach(group => {
                const { count, sides } = group;
                if (count === 0) return;
                const isNegative = count < 0;
                const absCount = Math.abs(count);
                const rolls = Array.from({ length: absCount }, () => Math.ceil(Math.random() * sides));
                const subTotal = rolls.reduce((a, b) => a + b, 0);
                total += subTotal * (isNegative ? -1 : 1);
                detailParts.push(`[${rolls.join('+')}]`);
            });

            let detail = detailParts.join(' + ');
            if (mod !== 0) {
                detail += (mod > 0 ? ' + ' : ' - ') + Math.abs(mod);
            } else if (detailParts.length === 0) {
                detail = `${mod}`;
            }
            
            return { total, detail };
        }
        
        function convolveDistributions(distA, distB) {
            const newProbs = {};
            if (!distA || !distA.data || !distB || !distB.data) return { data: [], type: 'Error' };
            for (const p1 of distA.data) {
                for (const p2 of distB.data) {
                    const newValue = p1.value + p2.value;
                    const newProb = p1.probability * p2.probability;
                    newProbs[newValue] = (newProbs[newValue] || 0) + newProb;
                }
            }
            const newData = Object.entries(newProbs).map(([val, prob]) => ({ value: parseInt(val), probability: prob }));
            return { data: newData };
        }

        function syncUiToState() { for (const key in playgroundState) { const controlElement = ui.roll_builder.querySelector(`.die-control[data-key="${key}"]`); if (!controlElement) continue; if (key === 'meta') { controlElement.querySelector('[data-type="value"]').value = playgroundState.meta.value; controlElement.querySelector('[data-type="dc"]').value = playgroundState.meta.dc; } else { controlElement.querySelector('[data-type="count"]').value = playgroundState[key].count; controlElement.querySelector('[data-type="dropLow"]').value = playgroundState[key].dropLow; controlElement.querySelector('[data-type="dropHigh"]').value = playgroundState[key].dropHigh; const dieState = playgroundState[key]; const absCount = Math.abs(dieState.count); const maxDrops = absCount > 0 ? absCount - 1 : 0; const totalDrops = dieState.dropLow + dieState.dropHigh; const canIncreaseDrops = absCount === 0 || totalDrops >= maxDrops; controlElement.querySelector('[data-type="dropLow"]').parentElement.querySelector('[data-action="increase"]').disabled = canIncreaseDrops; controlElement.querySelector('[data-type="dropLow"]').parentElement.querySelector('[data-action="decrease"]').disabled = dieState.dropLow <= 0; controlElement.querySelector('[data-type="dropHigh"]').parentElement.querySelector('[data-action="increase"]').disabled = canIncreaseDrops; controlElement.querySelector('[data-type="dropHigh"]').parentElement.querySelector('[data-action="decrease"]').disabled = dieState.dropHigh <= 0; } } }
        
        // --- CHARTING ---
        function drawDistributionChart(containerEl, infoEl, options) {
            const { data: currentResult, frozenData, rollResult, dc, xAxisLabel, yAxisLabel, yAxisFormat, infoText, subtitle, isCalculatorChart = false } = options;
            
            let currentProbs = [];
            if (hasData(currentResult)) {
                if (isCalculatorChart) {
                    currentProbs = currentResult.data.filter(d => d.value !== 0 || currentResult.data.length === 1);
                } else {
                    currentProbs = currentResult.data;
                }
            }

            let frozenProbs = [];
            if (hasData(frozenData)) {
                if (isCalculatorChart) {
                    frozenProbs = frozenData.data.filter(d => d.value !== 0 || frozenData.data.length === 1);
                } else {
                    frozenProbs = frozenData.data;
                }
            }
            
            const hasCurrentData = currentProbs.length > 0;
            const hasFrozenData = frozenProbs.length > 0;
            
            if (!hasCurrentData && !hasFrozenData) { containerEl.innerHTML = `<p class="chart-message">No non-zero outcomes to display.</p>`; infoEl.innerHTML = infoText || ''; return; }
            
            const allPoints = [...currentProbs, ...frozenProbs]; allPoints.sort((a,b) => a.value - b.value);
            const svgWidth = containerEl.clientWidth; const svgHeight = 300; const margin = { top: 30, right: 20, bottom: 40, left: 50 }; const chartWidth = svgWidth - margin.left - margin.right; const chartHeight = svgHeight - margin.top - margin.bottom;
            const minSum = Math.min(...allPoints.map(p => p.value)); const maxSum = Math.max(...allPoints.map(p => p.value));
            const maxYValue = Math.max(0.001, ...allPoints.map(p => p.probability)); 
            
            infoEl.innerHTML = infoText || '';
            const generatePathData = (probs) => { if (probs.length === 0) return ''; probs.sort((a, b) => a.value - b.value); const points = probs.map(p => ({ x: margin.left + ((p.value - minSum) / (maxSum - minSum || 1)) * chartWidth, y: margin.top + chartHeight - (p.probability / maxYValue) * chartHeight })); return points.map((p, i) => (i === 0 ? 'M' : 'L') + `${p.x.toFixed(2)} ${p.y.toFixed(2)}`).join(' '); };
            
            const generateCircles = (probs, className) => {
                if (probs.length === 0) return '';
                return probs.map(p => {
                    const x = margin.left + ((p.value - minSum) / (maxSum - minSum || 1)) * chartWidth;
                    const y = margin.top + chartHeight - (p.probability / maxYValue) * chartHeight;
                    const titleText = yAxisFormat === 'number'
                        ? `AC: ${p.value}\nAvg Dmg: ${p.probability.toFixed(2)}`
                        : `Value: ${p.value}\nProb: ${(p.probability * 100).toFixed(2)}%`;
                    return `<circle cx="${x.toFixed(2)}" cy="${y.toFixed(2)}" r="3.5" class="${className}"><title>${titleText}</title></circle>`;
                }).join('');
            };

            const currentPath = hasCurrentData ? `<path d="${generatePathData(currentProbs)}" class="chart-line" />` : '';
            const frozenPath = hasFrozenData ? `<path d="${generatePathData(frozenProbs)}" class="frozen-line" />` : '';
            const currentCircles = generateCircles(currentProbs, 'chart-dot-current');
            const frozenCircles = generateCircles(frozenProbs, 'chart-dot-frozen');

            let dcElements = ''; if (hasCurrentData && dc > 0 && dc >= minSum && dc <= maxSum && yAxisFormat === 'percent') { const successChance = currentProbs.filter(p => p.value >= dc).reduce((acc, p) => acc + p.probability, 0); const dc_x = margin.left + ((dc - minSum) / (maxSum - minSum || 1)) * chartWidth; dcElements = `<line class="dc-line" x1="${dc_x}" y1="${margin.top}" x2="${dc_x}" y2="${margin.top + chartHeight}" /><text class="dc-text" x="${dc_x + 4}" y="${margin.top + 12}">DC ${dc}</text><text class="dc-text" x="${dc_x + 4}" y="${margin.top + 24}">Success: ${(successChance * 100).toFixed(1)}%</text>`; }
            let resultElement = ''; if (hasCurrentData && rollResult !== null && rollResult >= minSum && rollResult <= maxSum && yAxisFormat === 'percent') { const result_x = margin.left + ((rollResult - minSum) / (maxSum - minSum || 1)) * chartWidth; const percentile = currentProbs.filter(p => p.value <= rollResult).reduce((acc, p) => acc + p.probability, 0); const percentileText = (percentile * 100).toFixed(1); resultElement = `<line class="result-line" x1="${result_x}" y1="${margin.top}" x2="${result_x}" y2="${margin.top + chartHeight}" /><text class="result-text" x="${result_x + 4}" y="${margin.top + chartHeight - 15}"><tspan x="${result_x + 4}" dy="0">Result: ${rollResult}</tspan><tspan x="${result_x + 4}" dy="1.2em">(${percentileText}%)</tspan></text>`; }
            
            const subtitleElement = `<text class="chart-subtitle" x="${margin.left}" y="${margin.top - 8}">${subtitle || ''}</text>`;
            
            containerEl.innerHTML = `<svg width="${svgWidth}" height="${svgHeight}">${getAxisHTML(allPoints, maxYValue, margin, chartWidth, chartHeight, svgHeight, minSum, maxSum, xAxisLabel, yAxisLabel, yAxisFormat)}${subtitleElement}${frozenPath}${currentPath}${frozenCircles}${currentCircles}${dcElements}${resultElement}</svg>`;
        }
        function getAxisHTML(points, maxYValue, margin, chartWidth, chartHeight, svgHeight, minSum, maxSum, xAxisLabel, yAxisLabel, yAxisFormat) {
            const yAxisTicks = [...Array(6)].map((_, i) => {
                const yVal = (maxYValue / 5) * i;
                const y = margin.top + chartHeight - (yVal / maxYValue) * chartHeight;
                let tickLabel = '';
                if (yAxisFormat === 'number') {
                    tickLabel = yVal.toLocaleString(undefined, { maximumFractionDigits: 1 });
                } else { 
                    tickLabel = `${(yVal * 100).toFixed(1)}%`;
                }
                return `<g class="axis-tick"><line x1="${margin.left - 5}" y1="${y}" x2="${margin.left}" y2="${y}" /><text x="${margin.left - 8}" y="${y}" dy="3" text-anchor="end">${tickLabel}</text></g>`;
            }).join('');
            const yAxisFull = `<g class="axis-y"><line class="axis-line" x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + chartHeight}" />${yAxisTicks}<text class="axis-label" transform="translate(${margin.left / 3}, ${margin.top + chartHeight / 2}) rotate(-90)" text-anchor="middle">${yAxisLabel}</text></g>`;
            
            const range = maxSum - minSum;
            const numTicks = Math.min(Math.ceil(range) + 1, 20);
            const tickPoints = [];
            if (range > 0) { 
                const interval = Math.max(1, Math.round(range / numTicks)); 
                for(let i = minSum; i <= maxSum; i += interval){ 
                    const p = points.find(pt => pt.value >= i); 
                    if(p && !tickPoints.find(tp => tp.value === p.value)) {
                        tickPoints.push(p);
                    }
                } 
                const lastPoint = points.find(p => p.value === maxSum) || points[points.length-1];
                if(lastPoint && !tickPoints.find(p => p.value === lastPoint.value)) {
                    tickPoints.push(lastPoint);
                }
            } else if (points.length > 0) { 
                tickPoints.push(points[0]); 
            } 
            const xAxisTicks = tickPoints.map(p => { const x = margin.left + ((p.value - minSum) / (range || 1)) * chartWidth; return `<g class="axis-tick"><line x1="${x}" y1="${margin.top + chartHeight}" x2="${x}" y2="${margin.top + chartHeight + 5}" /><text x="${x}" y="${margin.top + chartHeight + 15}" text-anchor="middle">${p.value}</text></g>`; }).join(''); 
            const xAxisFull = `<g class="axis-x"><line class="axis-line" x1="${margin.left}" y1="${margin.top + chartHeight}" x2="${margin.left + chartWidth}" y2="${margin.top + chartHeight}" />${xAxisTicks}<text class="axis-label" x="${margin.left + chartWidth / 2}" y="${svgHeight - 5}" text-anchor="middle">${xAxisLabel}</text></g>`; return xAxisFull + yAxisFull;
        }

        initializeApp();
    </script>
</body>
</html>
