(function(){"use strict";var bt={exports:{}},y={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ct;function $t(){if(Ct)return y;Ct=1;var o=Symbol.for("react.transitional.element"),n=Symbol.for("react.portal"),u=Symbol.for("react.fragment"),c=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),a=Symbol.for("react.consumer"),s=Symbol.for("react.context"),r=Symbol.for("react.forward_ref"),p=Symbol.for("react.suspense"),C=Symbol.for("react.memo"),E=Symbol.for("react.lazy"),h=Symbol.for("react.activity"),m=Symbol.iterator;function M(t){return t===null||typeof t!="object"?null:(t=m&&t[m]||t["@@iterator"],typeof t=="function"?t:null)}var D={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},j=Object.assign,d={};function _(t,e,l){this.props=t,this.context=e,this.refs=d,this.updater=l||D}_.prototype.isReactComponent={},_.prototype.setState=function(t,e){if(typeof t!="object"&&typeof t!="function"&&t!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")},_.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")};function w(){}w.prototype=_.prototype;function $(t,e,l){this.props=t,this.context=e,this.refs=d,this.updater=l||D}var L=$.prototype=new w;L.constructor=$,j(L,_.prototype),L.isPureReactComponent=!0;var nt=Array.isArray;function q(){}var k={H:null,A:null,T:null,S:null},F=Object.prototype.hasOwnProperty;function Z(t,e,l){var f=l.ref;return{$$typeof:o,type:t,key:e,ref:f!==void 0?f:null,props:l}}function G(t,e){return Z(t.type,e,t.props)}function ot(t){return typeof t=="object"&&t!==null&&t.$$typeof===o}function T(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,function(l){return e[l]})}var Y=/\/+/g;function b(t,e){return typeof t=="object"&&t!==null&&t.key!=null?T(""+t.key):e.toString(36)}function z(t){switch(t.status){case"fulfilled":return t.value;case"rejected":throw t.reason;default:switch(typeof t.status=="string"?t.then(q,q):(t.status="pending",t.then(function(e){t.status==="pending"&&(t.status="fulfilled",t.value=e)},function(e){t.status==="pending"&&(t.status="rejected",t.reason=e)})),t.status){case"fulfilled":return t.value;case"rejected":throw t.reason}}throw t}function X(t,e,l,f,H){var g=typeof t;(g==="undefined"||g==="boolean")&&(t=null);var R=!1;if(t===null)R=!0;else switch(g){case"bigint":case"string":case"number":R=!0;break;case"object":switch(t.$$typeof){case o:case n:R=!0;break;case E:return R=t._init,X(R(t._payload),e,l,f,H)}}if(R)return H=H(t),R=f===""?"."+b(t,0):f,nt(H)?(l="",R!=null&&(l=R.replace(Y,"$&/")+"/"),X(H,e,l,"",function(rt){return rt})):H!=null&&(ot(H)&&(H=G(H,l+(H.key==null||t&&t.key===H.key?"":(""+H.key).replace(Y,"$&/")+"/")+R)),e.push(H)),1;R=0;var I=f===""?".":f+":";if(nt(t))for(var O=0;O<t.length;O++)f=t[O],g=I+b(f,O),R+=X(f,e,l,g,H);else if(O=M(t),typeof O=="function")for(t=O.call(t),O=0;!(f=t.next()).done;)f=f.value,g=I+b(f,O++),R+=X(f,e,l,g,H);else if(g==="object"){if(typeof t.then=="function")return X(z(t),e,l,f,H);throw e=String(t),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.")}return R}function et(t,e,l){if(t==null)return t;var f=[],H=0;return X(t,f,"","",function(g){return e.call(l,g,H++)}),f}function J(t){if(t._status===-1){var e=t._result;e=e(),e.then(function(l){(t._status===0||t._status===-1)&&(t._status=1,t._result=l)},function(l){(t._status===0||t._status===-1)&&(t._status=2,t._result=l)}),t._status===-1&&(t._status=0,t._result=e)}if(t._status===1)return t._result.default;throw t._result}var V=typeof reportError=="function"?reportError:function(t){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var e=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof t=="object"&&t!==null&&typeof t.message=="string"?String(t.message):String(t),error:t});if(!window.dispatchEvent(e))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",t);return}console.error(t)},W={map:et,forEach:function(t,e,l){et(t,function(){e.apply(this,arguments)},l)},count:function(t){var e=0;return et(t,function(){e++}),e},toArray:function(t){return et(t,function(e){return e})||[]},only:function(t){if(!ot(t))throw Error("React.Children.only expected to receive a single React element child.");return t}};return y.Activity=h,y.Children=W,y.Component=_,y.Fragment=u,y.Profiler=i,y.PureComponent=$,y.StrictMode=c,y.Suspense=p,y.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=k,y.__COMPILER_RUNTIME={__proto__:null,c:function(t){return k.H.useMemoCache(t)}},y.cache=function(t){return function(){return t.apply(null,arguments)}},y.cacheSignal=function(){return null},y.cloneElement=function(t,e,l){if(t==null)throw Error("The argument must be a React element, but you passed "+t+".");var f=j({},t.props),H=t.key;if(e!=null)for(g in e.key!==void 0&&(H=""+e.key),e)!F.call(e,g)||g==="key"||g==="__self"||g==="__source"||g==="ref"&&e.ref===void 0||(f[g]=e[g]);var g=arguments.length-2;if(g===1)f.children=l;else if(1<g){for(var R=Array(g),I=0;I<g;I++)R[I]=arguments[I+2];f.children=R}return Z(t.type,H,f)},y.createContext=function(t){return t={$$typeof:s,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null},t.Provider=t,t.Consumer={$$typeof:a,_context:t},t},y.createElement=function(t,e,l){var f,H={},g=null;if(e!=null)for(f in e.key!==void 0&&(g=""+e.key),e)F.call(e,f)&&f!=="key"&&f!=="__self"&&f!=="__source"&&(H[f]=e[f]);var R=arguments.length-2;if(R===1)H.children=l;else if(1<R){for(var I=Array(R),O=0;O<R;O++)I[O]=arguments[O+2];H.children=I}if(t&&t.defaultProps)for(f in R=t.defaultProps,R)H[f]===void 0&&(H[f]=R[f]);return Z(t,g,H)},y.createRef=function(){return{current:null}},y.forwardRef=function(t){return{$$typeof:r,render:t}},y.isValidElement=ot,y.lazy=function(t){return{$$typeof:E,_payload:{_status:-1,_result:t},_init:J}},y.memo=function(t,e){return{$$typeof:C,type:t,compare:e===void 0?null:e}},y.startTransition=function(t){var e=k.T,l={};k.T=l;try{var f=t(),H=k.S;H!==null&&H(l,f),typeof f=="object"&&f!==null&&typeof f.then=="function"&&f.then(q,V)}catch(g){V(g)}finally{e!==null&&l.types!==null&&(e.types=l.types),k.T=e}},y.unstable_useCacheRefresh=function(){return k.H.useCacheRefresh()},y.use=function(t){return k.H.use(t)},y.useActionState=function(t,e,l){return k.H.useActionState(t,e,l)},y.useCallback=function(t,e){return k.H.useCallback(t,e)},y.useContext=function(t){return k.H.useContext(t)},y.useDebugValue=function(){},y.useDeferredValue=function(t,e){return k.H.useDeferredValue(t,e)},y.useEffect=function(t,e){return k.H.useEffect(t,e)},y.useEffectEvent=function(t){return k.H.useEffectEvent(t)},y.useId=function(){return k.H.useId()},y.useImperativeHandle=function(t,e,l){return k.H.useImperativeHandle(t,e,l)},y.useInsertionEffect=function(t,e){return k.H.useInsertionEffect(t,e)},y.useLayoutEffect=function(t,e){return k.H.useLayoutEffect(t,e)},y.useMemo=function(t,e){return k.H.useMemo(t,e)},y.useOptimistic=function(t,e){return k.H.useOptimistic(t,e)},y.useReducer=function(t,e,l){return k.H.useReducer(t,e,l)},y.useRef=function(t){return k.H.useRef(t)},y.useState=function(t){return k.H.useState(t)},y.useSyncExternalStore=function(t,e,l){return k.H.useSyncExternalStore(t,e,l)},y.useTransition=function(){return k.H.useTransition()},y.version="19.2.0",y}var Et;function At(){return Et||(Et=1,bt.exports=$t()),bt.exports}At();const Pt=4e6,gt=5e4;function kt(o,n){if(n<0||n>o)return 0;if(n===0||n===o)return 1;n>o/2&&(n=o-n);let u=1;for(let c=1;c<=n;c++)u=u*(o-(c-1))/c;return u}function xt(o){let n=o,u=!0;const c=10;let i=0;for(;u&&i<c;){u=!1;const a=/(\d+)\s*\*\s*\(([^)]+)\)/,s=n.match(a);if(s){const r=parseInt(s[1],10),p=s[2],C=Array(r).fill(p).join(" + ");n=n.replace(s[0],C),u=!0}i++}return n}function st(o){const n={groups:[],mod:0,error:!1};if(!o||typeof o!="string"||o.trim()==="")return n;const i=xt(o.trim()).replace(/\s/g,"").replace(/([+-])/g," $1 ").split(" ").filter(s=>s);let a="+";for(const s of i){if(s==="+"||s==="-"){a=s;continue}const r=a==="+"?1:-1,p=s.match(/^(\d*)d(\d+)([kK][hHlL]\d+|[dD][hHlL]\d+)?$/);if(p){const E=p[1]===""?1:parseInt(p[1],10),h=parseInt(p[2],10),m=p[3];let M=E*r,D=0,j=0;if(h<=0){n.error=!0;continue}if(m){const d=m.substring(0,2).toLowerCase(),_=parseInt(m.substring(2),10),w=Math.abs(M);d==="kh"?D=Math.max(0,w-_):d==="kl"?j=Math.max(0,w-_):d==="dl"?D=_:d==="dh"&&(j=_),D=Math.min(D,w),j=Math.min(j,w-D)}n.groups.push({count:M,sides:h,dropLow:D,dropHigh:j});continue}if(s.match(/^\d+$/)){n.mod+=parseInt(s,10)*r;continue}n.error=!0}return n}function lt(o,n={}){const{groups:u,mod:c}=o;if(!u||u.length===0)return{data:[{value:c,probability:1}],type:"Constant"};let i={data:[{value:0,probability:1}],type:"Exact"};for(const a of u){const s=Math.abs(a.count);if(s===0)continue;const r=a.count>0;if(a.dropLow&&a.dropLow>0||a.dropHigh&&a.dropHigh>0){const C={},E=`d${a.sides}`;C[E]={count:a.count,dropLow:a.dropLow||0,dropHigh:a.dropHigh||0};const m=wt(C,{value:0});i=pt(i,m)}else{const C={data:[],type:"Exact"},E={};if(n.maximizedDamage){const m=r?a.sides:-a.sides;E[m]=1}else for(let m=1;m<=a.sides;m++){let M=1/a.sides;r&&(n.gwf?m<=2?M=2/a.sides*(1/a.sides):M=1/a.sides+2/a.sides*(1/a.sides):n.rerollOnes&&(m===1?M=1/a.sides*(1/a.sides):M=1/a.sides+1/a.sides*(1/a.sides)));let D=r?m:-m;r&&n.elementalAdept&&D===1&&(D=2),E[D]=(E[D]||0)+M}Object.entries(E).forEach(([m,M])=>{C.data.push({value:parseInt(m),probability:M})});let h={data:[{value:0,probability:1}],type:"Exact"};for(let m=0;m<s;m++)h=pt(h,C);i=pt(i,h)}}return i.data.forEach(a=>a.value+=c),i}function pt(o,n){const u={};if(!(o!=null&&o.data)||!(n!=null&&n.data))return{data:[],type:"Error"};if(o.data.length===0)return n;if(n.data.length===0)return o;for(const i of o.data)for(const a of n.data){const s=i.value+a.value,r=i.probability*a.probability;u[s]=(u[s]||0)+r}return{data:Object.entries(u).map(([i,a])=>({value:parseInt(i,10),probability:a})),type:o.type}}function ht(o){var s;if(!((s=o==null?void 0:o.data)!=null&&s.length))return null;const{data:n}=o,u=n.map(r=>r.value),c=Math.min(...u),i=Math.max(...u),a=n.reduce((r,p)=>r+p.value*p.probability,0);return{min:c,max:i,average:a}}function yt(o){if(!o||!o.data)return{data:[],type:"Error"};const n=[...o.data].sort((a,s)=>a.value-s.value),u=[];let c=0,i=0;for(const a of n){i+=a.probability;const s=i,p=s*s-c*c;u.push({value:a.value,probability:p}),c=s}return{data:u,type:o.type}}function _t(o,n,u=!1){let c=0;const i=[];for(const a in o){if(o[a].count===0)continue;const{count:s,dropLow:r,dropHigh:p}=o[a],C=parseInt(a.substring(1)),E=s<0,h=Math.abs(s);if(C<=0)continue;const m=Array.from({length:h},()=>Math.floor(Math.random()*C)+1);let M=m;if(r>0||p>0){const d=[...m].sort((w,$)=>w-$).slice(r),_=d.length-p;M=d.slice(0,Math.max(0,_))}let D=M.reduce((j,d)=>j+d,0);if(E&&(D*=-1),c+=D,u){let j=`${Math.abs(s)}D${C}`;r>0&&(j+=`dl${r}`),p>0&&(j+=`dh${p}`),E&&(j="-"+j);let d=`<b>${j}</b>: [${m.join(", ")}]`;(r>0||p>0)&&(d+=` âž” Kept [${M.join(", ")}]`),d+=` = ${D}`,i.push(d)}}return c+=n.value,u?(n.value!==0&&i.push(`<b>Modifier</b>: ${n.value>0?"+":""}${n.value}`),{grandTotal:c,detailParts:i}):{grandTotal:c}}function Ht(o,n){return _t(o,n,!0)}function Ot(o,n){let u={0:1},c=0;for(const s in o){if(o[s].count===0)continue;const{count:r}=o[s],p=parseInt(s.substring(1),10);c+=Math.abs(r);for(let C=0;C<Math.abs(r);C++){const E={};for(const h in u)for(let m=1;m<=p;m++){const M=r>0?m:-m,D=parseInt(h,10)+M;E[D]=(E[D]||0)+u[h]}u=E}}if(c===0)return{data:[],type:"Empty"};const i=Object.values(u).reduce((s,r)=>s+r,0);return{data:Object.entries(u).map(([s,r])=>({value:parseInt(s,10)+n.value,probability:r/i})),type:"Exact"}}function St(o,n){const u=Object.entries(o).filter(([,s])=>s.count!==0).map(([s,r])=>({...r,sides:parseInt(s.substring(1),10)}));if(u.length===0)return{data:[],type:"Empty"};const c={};let i=0;function a(s,r){if(s===u.length){c[r]=(c[r]||0)+1,i++;return}const p=u[s],C=Math.abs(p.count);function E(h,m){if(h===C){const D=[...m].sort((_,w)=>_-w).slice(p.dropLow);let d=D.slice(0,Math.max(0,D.length-p.dropHigh)).reduce((_,w)=>_+w,0);p.count<0&&(d*=-1),a(s+1,r+d);return}for(let M=1;M<=p.sides;M++)E(h+1,[...m,M])}E(0,[])}return a(0,n.value),{data:Object.entries(c).map(([s,r])=>({value:parseInt(s,10),probability:r/i})),type:"Exact"}}function jt(o,n){const u={};for(let s=0;s<gt;s++){const{grandTotal:r}=_t(o,n);u[r]=(u[r]||0)+1}let c=Object.entries(u).map(([s,r])=>({value:parseInt(s,10),probability:r/gt}));c.sort((s,r)=>s.value-r.value);const i=[];if(c.length>0){const s=c[0].value,r=c[c.length-1].value;let p=0;for(let C=s;C<=r;C++)c[p]&&c[p].value===C?(i.push(c[p]),p++):i.push({value:C,probability:0})}return{data:i.map((s,r,p)=>{const C=p[r-1]?p[r-1].probability:s.probability,E=p[r+1]?p[r+1].probability:s.probability;return{value:s.value,probability:(C+s.probability+E)/3}}),type:`Estimated (${gt/1e3}k sims)`}}function wt(o,n){const u=Object.values(o).some(i=>i.count<0);return Object.values(o).some(i=>i.dropLow>0||i.dropHigh>0)||u?Object.entries(o).filter(([,a])=>a.count!==0).reduce((a,[s,r])=>a*Math.pow(parseInt(s.substring(1),10),Math.abs(r.count)),1)>Pt?jt(o,n):St(o,n):Ot(o,n)}function Lt(o){const{advState:n,targetAC:u,atkBonus:c,damageDice:i,numAttacks:a,gwmss:s,gwf:r,elementalAdept:p,critThreshold:C,halflingLuck:E,statusEffect:h,brutalCritical:m,resistance:M,savageAttacker:D,autoCrit:j,maximizedDamage:d,damageOnMiss:_,oncePerTurnDamage:w,precisionDie:$,precisionThreshold:L,precisionMaxUses:nt,critRule:q}=o,k=parseInt(a,10)||1;let F=0;const Z=[],G={crit:0,hit:0,miss:0};let ot=!1,T=0;const Y=nt??100,b=typeof L=="number"?L:parseInt(L||"0",10);let z=c;h==="bless"&&(z+="+1d4"),h==="bane"&&(z+="-1d4");const X=st(z),J=st(i),V=st(w||"");s&&(X.mod-=5,J.mod+=10);const W=parseInt(u,10),t=parseInt(C||"20",10),e=$&&$!=="none"?st($):null;let l=M;p&&l==="resist"&&(l="none");const f=(g,R=!1)=>{let I=R?V:J,O=I.mod,rt=[],it=0,tt=[];if(I.groups.forEach(x=>{g&&!R?q==="crunchy"?(tt.push(x),it+=Math.abs(x.count)*x.sides):(tt.push(x),tt.push(x)):tt.push(x)}),g&&!R&&m&&m>0&&I.groups.length>0){const x=I.groups[0];tt.push({count:m,sides:x.sides})}return O+=it,tt.forEach(x=>{const U=[],at=x.count>0,Q=Math.abs(x.count),v=x.dropLow&&x.dropLow>0||x.dropHigh&&x.dropHigh>0;for(let S=0;S<Q;S++){let K=Math.ceil(Math.random()*x.sides);d?K=x.sides:(at&&r&&K<=2&&(K=Math.ceil(Math.random()*x.sides)),at&&p&&K===1&&(K=2)),U.push(K)}let A=U;if(v){const S=[...U].sort((P,N)=>P-N),K=x.dropLow||0,ft=x.dropHigh||0,ct=S.slice(K),ut=ct.length-ft;A=ct.slice(0,Math.max(0,ut))}let B=A.reduce((S,K)=>S+K,0);if(at||(B*=-1),O+=B,Q!==0){let S=`${Q}d${x.sides}`;x.dropLow&&(S+=`dl${x.dropLow}`),x.dropHigh&&(S+=`dh${x.dropHigh}`);let K=`${S}: [${U.join(",")}]`;v&&(K+=`->[${A.join(",")}]`),rt.push(K)}}),it>0&&rt.push(`+${it} (Max Crit)`),{total:O,breakdown:rt}};for(let g=0;g<k;g++){const R=[];let I=1;Math.abs(n)===1&&(I=2),n===2&&(I=3);for(let P=0;P<I;P++){let N=Math.ceil(Math.random()*20),mt="";E&&N===1&&(N=Math.ceil(Math.random()*20),mt=" (rerolled 1)"),R.push({val:N,note:mt})}let O=R[0];n>=1?O=R.reduce((P,N)=>N.val>P.val?N:P,R[0]):n===-1&&(O=R.reduce((P,N)=>N.val<P.val?N:P,R[0]));const rt=O.val;let it=X.mod;const tt=[];X.groups.forEach(P=>{const N=Array.from({length:Math.abs(P.count)},()=>Math.ceil(Math.random()*P.sides));let mt=N;if(P.dropLow||P.dropHigh){const vt=[...N].sort((Mt,Yt)=>Mt-Yt);mt=vt.slice(P.dropLow||0,vt.length-(P.dropHigh||0))}let dt=mt.reduce((vt,Mt)=>vt+Mt,0);P.count<0&&(dt*=-1),it+=dt,tt.push(`${Math.abs(P.count)}d${P.sides}:[${N.join(",")}]`)});const x=rt+it;let U="miss",at="";if(rt>=t?U="crit":rt===1?U="miss":x>=W&&(U="hit"),U==="miss"&&e&&rt!==1){const P=e.groups[0];if(P){const N=W-x,mt=T<Y;if(x+P.sides<W)at=" (Miss - Precision saved)";else if(N>b)at=` (Miss - Precision saved, gap > ${b})`;else if(!mt)at=" (Miss - Precision limit reached)";else{T++;const dt=Math.ceil(Math.random()*P.sides);x+dt>=W?(U="hit",at=` (Miss -> Hit! +${dt} Precision)`):at=` (Used Precision +${dt} but missed)`}}}j&&(U==="hit"||U==="crit")&&(U="crit"),G[U]++;let Q=0,v=[],A="",B="",S=!1;if(U!=="miss"){let P=f(U==="crit");if(D&&!d){let N=f(U==="crit");N.total>P.total?(Q=N.total,v=N.breakdown,A=` (Savage: ${P.total} vs ${N.total})`):(Q=P.total,v=P.breakdown,A=` (Savage: ${P.total} vs ${N.total})`)}else Q=P.total,v=P.breakdown;if(!ot&&!V.error&&(V.groups.length>0||V.mod>0)){const N=f(U==="crit",!0);Q+=N.total,ot=!0,S=!0}}else _>0&&(Q=_,B=` (Graze: ${_})`);l==="vuln"&&(Q*=2),l==="resist"&&(Q=Math.floor(Q/2)),l==="immune"&&(Q=0),Q=Math.max(0,Q),F+=Q;let K=U==="crit"?"text-amber-400":U==="hit"?"text-green-400":"text-red-500";const ft=`<span class="${K}">${U==="crit"?"Crit!":U==="hit"?"Hit!":"Miss"}</span>`;let ct=`[${R.map(P=>P.val).join(",")}]`;tt.length&&(ct+=` + ${tt.join("+")}`),X.mod!==0&&(ct+=` ${X.mod>0?"+":""}${X.mod}`);let ut="";U!=="miss"?(ut=`Dmg: <span class="${K}">${Q}</span> (${v.join(" + ")}${J.mod!==0?` ${J.mod>0?"+":""}${J.mod}`:""})`,S&&(ut+=" + Sneak/Once"),A&&(ut+=A)):B&&(ut=B),Z.push(`<b>Atk ${g+1}:</b> ${ft} (${ct} = ${x}${at}) ${ut}`)}return{outcome:`${G.crit} Crits, ${G.hit} Hits, ${G.miss} Misses`+(T?` (${T} Precision Used)`:""),details:Z.join("<br/>"),damage:F}}function It(o){var Q;const{atkBonus:n,targetAC:u,damageDice:c,advState:i,gwmss:a,gwf:s,elementalAdept:r,critThreshold:p,halflingLuck:C,statusEffect:E,brutalCritical:h,resistance:m,savageAttacker:M,autoCrit:D,maximizedDamage:j,precisionDie:d,critRule:_,precisionThreshold:w}=o;let $=String(n);E==="bless"&&($+="+1d4"),E==="bane"&&($+="-1d4");const L=st($),q=st(c);if(a&&(L.mod-=5,q.mod+=10),q.error||L.error)return null;const k=parseInt(p||"20",10),F=Ut(C),Z=new Array(21).fill(0);for(let v=1;v<=20;v++)Z[v]=Z[v-1]+F[v];const G=new Array(21).fill(0);for(let v=1;v<=20;v++){let A=Z[v],B=Z[v-1],S=0,K=0;if(i===-1)S=1-Math.pow(1-A,2),K=1-Math.pow(1-B,2);else{let ft=i===0?1:i===1?2:3;S=Math.pow(A,ft),K=Math.pow(B,ft)}G[v]=S-K}const ot=lt(L),T=parseInt(u,10),Y=d&&d!=="none"?st(d):null,b=Y?lt(Y):null,z=b&&((Q=ht(b))==null?void 0:Q.max)||0,X=typeof w=="number"?w:parseInt(w||"0",10);let et=0,J=0,V=0,W=0;for(const v of ot.data)for(let A=1;A<=20;A++){const B=G[A],S=A+v.value;if(A>=k)et+=B*v.probability;else if(A>1&&S>=T)J+=B*v.probability;else if(A>1&&b&&T-S<=z&&T-S<=X){const K=T-S,ft=b.data.filter(P=>P.value>=K).reduce((P,N)=>P+N.probability,0),ct=B*v.probability;V+=ct;const ut=ct*ft;W+=ut,J+=ut}}D&&(et+=J,J=0);const t=1-et-J;let e=lt(q,{gwf:s,elementalAdept:r,maximizedDamage:j}),l;const f=q.groups,H=q.mod;if(_==="crunchy"){const v=f.reduce((A,B)=>A+Math.abs(B.count)*B.sides,0);if(l={type:e.type,data:e.data.map(A=>({...A,value:A.value+v}))},h&&h>0&&f.length>0){const A=[{...f[0],count:h,sides:f[0].sides}],B=lt({groups:A,mod:0});l=pt(l,B)}}else{const v=[];f.forEach(A=>{A.dropLow||A.dropHigh?(v.push(A),v.push(A)):v.push({...A,count:A.count*2})}),h&&h>0&&f.length>0&&v.push({count:h,sides:f[0].sides}),l=lt({groups:v,mod:H},{gwf:s,elementalAdept:r,maximizedDamage:j})}M&&!j&&(e=yt(e),_!=="crunchy"&&(l=yt(l)));let g=m;r&&g==="resist"&&(g="none");const R=v=>{if(g==="none")return v;const A={};return v.data.forEach(B=>{let S=B.value;g==="vuln"&&(S*=2),g==="resist"&&(S=Math.floor(S/2)),g==="immune"&&(S=0),S=Math.max(0,S),A[S]=(A[S]||0)+B.probability}),{type:v.type,data:Object.entries(A).map(([B,S])=>({value:Number(B),probability:Number(S)}))}};e=R(e),l=R(l);const I={};let O=o.damageOnMiss||0;O>0&&(g==="vuln"&&(O*=2),g==="resist"&&(O=Math.floor(O/2)),g==="immune"&&(O=0),O=Math.max(0,O)),t>0&&(I[O]=(I[O]||0)+t),e.data.forEach(v=>I[v.value]=(I[v.value]||0)+v.probability*J),l.data.forEach(v=>I[v.value]=(I[v.value]||0)+v.probability*et);const rt={type:"Exact",data:Object.entries(I).map(([v,A])=>({value:Number(v),probability:A}))},it=ht(e),tt=ht(l),x=(it==null?void 0:it.average)||0,U=Y&&V>0?W*(x-O)/V:void 0,at={adpr:J*x+et*((tt==null?void 0:tt.average)||0)+t*O,critChance:et,hitChance:J,missChance:t,avgDamage:x,avgCritDamage:(tt==null?void 0:tt.average)||0,damagePerPrecisionDie:U,precisionHitChance:W>0?W:void 0,precisionTriggerChance:V>0?V:void 0};return{distribution:rt,summary:at}}function Tt(o){var j;const{oncePerTurnDamage:n,gwf:u,elementalAdept:c,maximizedDamage:i,savageAttacker:a,resistance:s}=o,r=st(n||"");let p=0,C=null,E=s;if(c&&E==="resist"&&(E="none"),!r.error&&(r.groups.length>0||r.mod>0)){let d=lt(r,{gwf:u,elementalAdept:c,maximizedDamage:i});a&&!i&&(d=yt(d));const _={};d.data.forEach($=>{let L=$.value;E==="vuln"&&(L*=2),E==="resist"&&(L=Math.floor(L/2)),E==="immune"&&(L=0),_[L]=(_[L]||0)+$.probability}),C={type:d.type,data:Object.entries(_).map(([$,L])=>({value:Number($),probability:Number(L)}))};const w=ht(C);w&&(p=w.average)}if(o.chartMode==="variable"){const d=[];for(let w=1;w<=30;w++){const $=Tt({...o,targetAC:String(w),chartMode:"fixed"});$&&d.push({value:w,probability:$.summary.adpr})}return{distribution:{data:d,type:"Variable"},summary:{adpr:0,avgCritDamage:0,avgDamage:0,critChance:0,hitChance:0,missChance:0}}}const h=It(o);if(!h)return null;const m=parseInt(o.numAttacks,10);let M=h.distribution;for(let d=1;d<m;d++)M=pt(M,h.distribution);let D={...h.summary,adpr:h.summary.adpr*m};if(h.summary.precisionHitChance&&h.summary.precisionTriggerChance){const d=h.summary.precisionTriggerChance,_=h.summary.precisionHitChance/d,w=o.precisionMaxUses||100,$=m;let L=0;for(let G=1;G<=$;G++){const ot=kt($,G)*Math.pow(d,G)*Math.pow(1-d,$-G);L+=Math.min(G,w)*ot}const nt=L*_,k=$*h.summary.precisionHitChance-nt;let F=o.damageOnMiss||0;E==="vuln"&&(F*=2),E==="resist"&&(F=Math.floor(F/2)),E==="immune"&&(F=0);const Z=h.summary.avgDamage-F;D.adpr-=k*Z}if(C){const d=1-Math.pow(h.summary.missChance,m);if(D.adpr+=d*p,o.damageOnMiss===0){const _=((j=M.data.find($=>$.value===0))==null?void 0:j.probability)||0,w={type:M.type,data:M.data.filter($=>$.value>0)};if(w.data.length>0){const $=pt(w,C),L=[..._>0?[{value:0,probability:_}]:[],...$.data];M={type:M.type,data:L}}}}return{summary:D,distribution:M}}function Nt(o){const{advState:n,saveDC:u,saveBonus:c,damageDice:i,saveOutcome:a,numTargets:s,evasion:r,resistance:p,elementalAdept:C,rerollOnes:E}=o,h=parseInt(s,10)||1;let m=0,M=0;const D=[],j=st(c),d=st(i),_=parseInt(u,10);let w=p;C&&w==="resist"&&(w="none");for(let $=0;$<h;$++){const L=Math.ceil(Math.random()*20),nt=Math.ceil(Math.random()*20);let q=L;n===1&&(q=Math.max(L,nt)),n===-1&&(q=Math.min(L,nt));let k=j.mod;j.groups.forEach(b=>{for(let z=0;z<Math.abs(b.count);z++)k+=Math.ceil(Math.random()*b.sides)*(b.count>0?1:-1)});const F=q+k,Z=F>=_;Z&&M++;let G=d.mod;d.groups.forEach(b=>{const z=[],X=Math.abs(b.count);for(let V=0;V<X;V++){let W=Math.ceil(Math.random()*b.sides);b.count>0&&E&&W===1&&(W=Math.ceil(Math.random()*b.sides)),b.count>0&&C&&W===1&&(W=2),z.push(W)}let et=z;if(b.dropLow||b.dropHigh){const V=[...z].sort((W,t)=>W-t);et=V.slice(b.dropLow||0,V.length-(b.dropHigh||0))}let J=et.reduce((V,W)=>V+W,0);b.count<0&&(J*=-1),G+=J});let T=Math.floor(G*(Z?r?0:a:r?.5:1));w==="vuln"&&(T*=2),w==="resist"&&(T=Math.floor(T/2)),w==="immune"&&(T=0),T=Math.max(0,T),m+=T;const Y=Z?'<span class="text-green-400">Success</span>':'<span class="text-red-500">Fail</span>';D.push(`<b>Target ${$+1}:</b> ${Y} (Roll ${F}) Dmg: ${T}`)}return{summaryText:`${M} Saves, ${h-M} Fails`,details:D.join("<br>"),damage:m}}function Rt(o){const{saveDC:n,damageDice:u,saveBonus:c,advState:i,saveOutcome:a,numTargets:s,evasion:r,resistance:p,elementalAdept:C,rerollOnes:E}=o;if(o.chartMode==="variable"){const T=[];for(let b=1;b<=30;b++){const z={...o,saveDC:String(b),chartMode:"fixed"},X=Rt(z);X&&T.push({value:b,probability:X.summary.totalAvgDamage})}return{distribution:{data:T,type:"Variable"},summary:{totalAvgDamage:0,successChance:0,failChance:0,avgFailDamage:0,avgSuccessDamage:0}}}const h=st(u),m=st(c);if(h.error||m.error)return null;const M=parseInt(n,10);let D=p;C&&D==="resist"&&(D="none");const j=lt(h,{elementalAdept:C,rerollOnes:E}),d=lt(m);let _=0;const w=new Array(21).fill(0);for(let T=1;T<=20;T++)w[T]=T/20;d.data.forEach(T=>{const Y=M-T.value;let b=0;if(Y<=1)b=1;else if(Y>20)b=0;else{const z=w[Y-1];i===0&&(b=1-z),i===1&&(b=1-z*z),i===-1&&(b=(1-z)*(1-z))}_+=b*T.probability});const $=1-_;let L=r?.5:1,nt=r?0:a;const q={};j.data.forEach(T=>{let Y=Math.floor(T.value*L);D==="vuln"&&(Y*=2),D==="resist"&&(Y=Math.floor(Y/2)),D==="immune"&&(Y=0),q[Y]=(q[Y]||0)+T.probability*$;let b=Math.floor(T.value*nt);D==="vuln"&&(b*=2),D==="resist"&&(b=Math.floor(b/2)),D==="immune"&&(b=0),q[b]=(q[b]||0)+T.probability*_});const k={type:"Exact",data:Object.entries(q).map(([T,Y])=>({value:Number(T),probability:Number(Y)}))};let F=k;const Z=parseInt(s,10)||1;for(let T=1;T<Z;T++)F=pt(F,k);const G=ht(F),ot={totalAvgDamage:(G==null?void 0:G.average)||0,successChance:_,failChance:$,avgFailDamage:0,avgSuccessDamage:0};return{distribution:F,summary:ot}}function Ut(o){const n=new Array(21).fill(0);if(o){n[1]=.0025;for(let u=2;u<=20;u++)n[u]=.0525}else for(let u=1;u<=20;u++)n[u]=.05;return n}const Dt=self;Dt.onmessage=o=>{const{id:n,type:u,payload:c}=o.data;try{let i;switch(u){case"playground_dist":i=wt(c.state,c.meta);break;case"playground_sim":i=Ht(c.state,c.meta);break;case"attack_dist":i=Tt(c.params);break;case"attack_sim":i=Lt(c.params);break;case"save_dist":i=Rt(c.params);break;case"save_sim":i=Nt(c.params);break;default:throw new Error(`Unknown calculation type: ${u}`)}Dt.postMessage({id:n,success:!0,result:i})}catch(i){Dt.postMessage({id:n,success:!1,error:i.message})}}})();
